// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.4.2
//   protoc               v3.19.1
// source: rpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';

export const protobufPackage = 'protowire';

/**
 * RPC-related types. Request messages, response messages, and dependant types.
 *
 * Clients are expected to build RequestMessages and wrap them in KaspadMessage. (see messages.proto)
 *
 * Having received a RequestMessage, (wrapped in a KaspadMessage) the RPC server will respond with a
 * ResponseMessage (likewise wrapped in a KaspadMessage) respective to the original RequestMessage.
 */

export enum RpcNotifyCommand {
  NOTIFY_START = 0,
  NOTIFY_STOP = 1,
  UNRECOGNIZED = -1
}

/**
 * RPCError represents a generic non-internal error.
 *
 * Receivers of any ResponseMessage are expected to check whether its error field is not null.
 */
export interface RPCError {
  message: string;
}

export interface RpcBlock {
  header: RpcBlockHeader | undefined;
  transactions: RpcTransaction[];
  verboseData: RpcBlockVerboseData | undefined;
}

export interface RpcBlockHeader {
  version: number;
  parents: RpcBlockLevelParents[];
  hashMerkleRoot: string;
  acceptedIdMerkleRoot: string;
  utxoCommitment: string;
  timestamp: number;
  bits: number;
  nonce: number;
  daaScore: number;
  blueWork: string;
  pruningPoint: string;
  blueScore: number;
}

export interface RpcBlockLevelParents {
  parentHashes: string[];
}

export interface RpcBlockVerboseData {
  hash: string;
  difficulty: number;
  selectedParentHash: string;
  transactionIds: string[];
  isHeaderOnly: boolean;
  blueScore: number;
  childrenHashes: string[];
  mergeSetBluesHashes: string[];
  mergeSetRedsHashes: string[];
  isChainBlock: boolean;
}

export interface RpcTransaction {
  version: number;
  inputs: RpcTransactionInput[];
  outputs: RpcTransactionOutput[];
  lockTime: number;
  subnetworkId: string;
  gas: number;
  payload: string;
  verboseData: RpcTransactionVerboseData | undefined;
  mass: number;
}

export interface RpcTransactionInput {
  previousOutpoint: RpcOutpoint | undefined;
  signatureScript: string;
  sequence: number;
  sigOpCount: number;
  verboseData: RpcTransactionInputVerboseData | undefined;
}

export interface RpcScriptPublicKey {
  version: number;
  scriptPublicKey: string;
}

export interface RpcTransactionOutput {
  amount: number;
  scriptPublicKey: RpcScriptPublicKey | undefined;
  verboseData: RpcTransactionOutputVerboseData | undefined;
}

export interface RpcOutpoint {
  transactionId: string;
  index: number;
}

export interface RpcUtxoEntry {
  amount: number;
  scriptPublicKey: string;
  blockDaaScore: number;
  isCoinbase: boolean;
}

export interface RpcTransactionVerboseData {
  transactionId: string;
  hash: string;
  computeMass: number;
  blockHash: string;
  blockTime: number;
}

export interface RpcTransactionInputVerboseData {}

export interface RpcTransactionOutputVerboseData {
  scriptPublicKeyType: string;
  scriptPublicKeyAddress: string;
}

/**
 * GetCurrentNetworkRequestMessage requests the network kaspad is currently running against.
 *
 * Possible networks are: Mainnet, Testnet, Simnet, Devnet
 */
export interface GetCurrentNetworkRequestMessage {}

export interface GetCurrentNetworkResponseMessage {
  currentNetwork: string;
  error: RPCError | undefined;
}

/**
 * SubmitBlockRequestMessage requests to submit a block into the DAG.
 * Blocks are generally expected to have been generated using the getBlockTemplate call.
 *
 * See: GetBlockTemplateRequestMessage
 */
export interface SubmitBlockRequestMessage {
  block: RpcBlock | undefined;
  allowNonDAABlocks: boolean;
}

export interface SubmitBlockResponseMessage {
  rejectReason: SubmitBlockResponseMessage_RejectReason;
  error: RPCError | undefined;
}

export enum SubmitBlockResponseMessage_RejectReason {
  NONE = 0,
  BLOCK_INVALID = 1,
  IS_IN_IBD = 2,
  UNRECOGNIZED = -1
}

/**
 * GetBlockTemplateRequestMessage requests a current block template.
 * Callers are expected to solve the block template and submit it using the submitBlock call
 *
 * See: SubmitBlockRequestMessage
 */
export interface GetBlockTemplateRequestMessage {
  /** Which kaspa address should the coinbase block reward transaction pay into */
  payAddress: string;
  extraData: string;
}

export interface GetBlockTemplateResponseMessage {
  block: RpcBlock | undefined;
  /**
   * Whether kaspad thinks that it's synced.
   * Callers are discouraged (but not forbidden) from solving blocks when kaspad is not synced.
   * That is because when kaspad isn't in sync with the rest of the network there's a high
   * chance the block will never be accepted, thus the solving effort would have been wasted.
   */
  isSynced: boolean;
  error: RPCError | undefined;
}

/**
 * NotifyBlockAddedRequestMessage registers this connection for blockAdded notifications.
 *
 * See: BlockAddedNotificationMessage
 */
export interface NotifyBlockAddedRequestMessage {
  command: RpcNotifyCommand;
}

export interface NotifyBlockAddedResponseMessage {
  error: RPCError | undefined;
}

/**
 * BlockAddedNotificationMessage is sent whenever a blocks has been added (NOT accepted)
 * into the DAG.
 *
 * See: NotifyBlockAddedRequestMessage
 */
export interface BlockAddedNotificationMessage {
  block: RpcBlock | undefined;
}

/**
 * GetPeerAddressesRequestMessage requests the list of known kaspad addresses in the
 * current network. (mainnet, testnet, etc.)
 */
export interface GetPeerAddressesRequestMessage {}

export interface GetPeerAddressesResponseMessage {
  addresses: GetPeerAddressesKnownAddressMessage[];
  bannedAddresses: GetPeerAddressesKnownAddressMessage[];
  error: RPCError | undefined;
}

export interface GetPeerAddressesKnownAddressMessage {
  Addr: string;
}

/**
 * GetSinkRequestMessage requests the hash of the current virtual's
 * selected parent.
 */
export interface GetSinkRequestMessage {}

export interface GetSinkResponseMessage {
  sink: string;
  error: RPCError | undefined;
}

/**
 * GetMempoolEntryRequestMessage requests information about a specific transaction
 * in the mempool.
 */
export interface GetMempoolEntryRequestMessage {
  /** The transaction's TransactionID. */
  txId: string;
  includeOrphanPool: boolean;
  filterTransactionPool: boolean;
}

export interface GetMempoolEntryResponseMessage {
  entry: RpcMempoolEntry | undefined;
  error: RPCError | undefined;
}

/**
 * GetMempoolEntriesRequestMessage requests information about all the transactions
 * currently in the mempool.
 */
export interface GetMempoolEntriesRequestMessage {
  includeOrphanPool: boolean;
  filterTransactionPool: boolean;
}

export interface GetMempoolEntriesResponseMessage {
  entries: RpcMempoolEntry[];
  error: RPCError | undefined;
}

export interface RpcMempoolEntry {
  fee: number;
  transaction: RpcTransaction | undefined;
  isOrphan: boolean;
}

/**
 * GetConnectedPeerInfoRequestMessage requests information about all the p2p peers
 * currently connected to this kaspad.
 */
export interface GetConnectedPeerInfoRequestMessage {}

export interface GetConnectedPeerInfoResponseMessage {
  infos: GetConnectedPeerInfoMessage[];
  error: RPCError | undefined;
}

export interface GetConnectedPeerInfoMessage {
  id: string;
  address: string;
  /** How long did the last ping/pong exchange take */
  lastPingDuration: number;
  /** Whether this kaspad initiated the connection */
  isOutbound: boolean;
  timeOffset: number;
  userAgent: string;
  /** The protocol version that this peer claims to support */
  advertisedProtocolVersion: number;
  /** The timestamp of when this peer connected to this kaspad */
  timeConnected: number;
  /** Whether this peer is the IBD peer (if IBD is running) */
  isIbdPeer: boolean;
}

/**
 * AddPeerRequestMessage adds a peer to kaspad's outgoing connection list.
 * This will, in most cases, result in kaspad connecting to said peer.
 */
export interface AddPeerRequestMessage {
  address: string;
  /** Whether to keep attempting to connect to this peer after disconnection */
  isPermanent: boolean;
}

export interface AddPeerResponseMessage {
  error: RPCError | undefined;
}

/** SubmitTransactionRequestMessage submits a transaction to the mempool */
export interface SubmitTransactionRequestMessage {
  transaction: RpcTransaction | undefined;
  allowOrphan: boolean;
}

export interface SubmitTransactionResponseMessage {
  /** The transaction ID of the submitted transaction */
  transactionId: string;
  error: RPCError | undefined;
}

/** SubmitTransactionReplacementRequestMessage submits a transaction to the mempool, applying a mandatory Replace by Fee policy */
export interface SubmitTransactionReplacementRequestMessage {
  transaction: RpcTransaction | undefined;
}

export interface SubmitTransactionReplacementResponseMessage {
  /** The transaction ID of the submitted transaction */
  transactionId: string;
  /** The previous transaction replaced in the mempool by the newly submitted one */
  replacedTransaction: RpcTransaction | undefined;
  error: RPCError | undefined;
}

/**
 * NotifyVirtualChainChangedRequestMessage registers this connection for virtualChainChanged notifications.
 *
 * See: VirtualChainChangedNotificationMessage
 */
export interface NotifyVirtualChainChangedRequestMessage {
  includeAcceptedTransactionIds: boolean;
  command: RpcNotifyCommand;
}

export interface NotifyVirtualChainChangedResponseMessage {
  error: RPCError | undefined;
}

/**
 * VirtualChainChangedNotificationMessage is sent whenever the DAG's selected parent
 * chain had changed.
 *
 * See: NotifyVirtualChainChangedRequestMessage
 */
export interface VirtualChainChangedNotificationMessage {
  /** The chain blocks that were removed, in high-to-low order */
  removedChainBlockHashes: string[];
  /** The chain blocks that were added, in low-to-high order */
  addedChainBlockHashes: string[];
  /** Will be filled only if `includeAcceptedTransactionIds = true` in the notify request. */
  acceptedTransactionIds: RpcAcceptedTransactionIds[];
}

/** GetBlockRequestMessage requests information about a specific block */
export interface GetBlockRequestMessage {
  /** The hash of the requested block */
  hash: string;
  /** Whether to include transaction data in the response */
  includeTransactions: boolean;
}

export interface GetBlockResponseMessage {
  block: RpcBlock | undefined;
  error: RPCError | undefined;
}

/**
 * GetSubnetworkRequestMessage requests information about a specific subnetwork
 *
 * Currently unimplemented
 */
export interface GetSubnetworkRequestMessage {
  subnetworkId: string;
}

export interface GetSubnetworkResponseMessage {
  gasLimit: number;
  error: RPCError | undefined;
}

/**
 * / GetVirtualChainFromBlockRequestMessage requests the virtual selected
 * / parent chain from some startHash to this kaspad's current virtual
 * / Note:
 * /     this call batches the response to:
 * /         a. the network's `mergeset size limit * 10` amount of added chain blocks, if `includeAcceptedTransactionIds = false`
 * /         b. or `mergeset size limit * 10` amount of merged blocks, if `includeAcceptedTransactionIds = true`
 * /         c. it does not batch the removed chain blocks, only the added ones.
 */
export interface GetVirtualChainFromBlockRequestMessage {
  startHash: string;
  includeAcceptedTransactionIds: boolean;
}

export interface RpcAcceptedTransactionIds {
  acceptingBlockHash: string;
  acceptedTransactionIds: string[];
}

export interface GetVirtualChainFromBlockResponseMessage {
  /** The chain blocks that were removed, in high-to-low order */
  removedChainBlockHashes: string[];
  /** The chain blocks that were added, in low-to-high order */
  addedChainBlockHashes: string[];
  /**
   * The transactions accepted by each block in addedChainBlockHashes.
   * Will be filled only if `includeAcceptedTransactionIds = true` in the request.
   */
  acceptedTransactionIds: RpcAcceptedTransactionIds[];
  error: RPCError | undefined;
}

/**
 * GetBlocksRequestMessage requests blocks between a certain block lowHash up to this
 * kaspad's current virtual.
 */
export interface GetBlocksRequestMessage {
  lowHash: string;
  includeBlocks: boolean;
  includeTransactions: boolean;
}

export interface GetBlocksResponseMessage {
  blockHashes: string[];
  blocks: RpcBlock[];
  error: RPCError | undefined;
}

/**
 * GetBlockCountRequestMessage requests the current number of blocks in this kaspad.
 * Note that this number may decrease as pruning occurs.
 */
export interface GetBlockCountRequestMessage {}

export interface GetBlockCountResponseMessage {
  blockCount: number;
  headerCount: number;
  error: RPCError | undefined;
}

/**
 * GetBlockDagInfoRequestMessage requests general information about the current state
 * of this kaspad's DAG.
 */
export interface GetBlockDagInfoRequestMessage {}

export interface GetBlockDagInfoResponseMessage {
  networkName: string;
  blockCount: number;
  headerCount: number;
  tipHashes: string[];
  difficulty: number;
  pastMedianTime: number;
  virtualParentHashes: string[];
  pruningPointHash: string;
  virtualDaaScore: number;
  sink: string;
  error: RPCError | undefined;
}

export interface ResolveFinalityConflictRequestMessage {
  finalityBlockHash: string;
}

export interface ResolveFinalityConflictResponseMessage {
  error: RPCError | undefined;
}

export interface NotifyFinalityConflictRequestMessage {
  command: RpcNotifyCommand;
}

export interface NotifyFinalityConflictResponseMessage {
  error: RPCError | undefined;
}

export interface FinalityConflictNotificationMessage {
  violatingBlockHash: string;
}

export interface FinalityConflictResolvedNotificationMessage {
  finalityBlockHash: string;
}

/** ShutdownRequestMessage shuts down this kaspad. */
export interface ShutdownRequestMessage {}

export interface ShutdownResponseMessage {
  error: RPCError | undefined;
}

/**
 * GetHeadersRequestMessage requests headers between the given startHash and the
 * current virtual, up to the given limit.
 */
export interface GetHeadersRequestMessage {
  startHash: string;
  limit: number;
  isAscending: boolean;
}

export interface GetHeadersResponseMessage {
  headers: string[];
  error: RPCError | undefined;
}

/**
 * NotifyUtxosChangedRequestMessage registers this connection for utxoChanged notifications
 * for the given addresses.
 *
 * This call is only available when this kaspad was started with `--utxoindex`
 *
 * See: UtxosChangedNotificationMessage
 */
export interface NotifyUtxosChangedRequestMessage {
  /**
   * UTXOs addresses to start/stop getting notified about
   * Leave empty to start/stop all updates
   */
  addresses: string[];
  command: RpcNotifyCommand;
}

export interface NotifyUtxosChangedResponseMessage {
  error: RPCError | undefined;
}

/**
 * UtxosChangedNotificationMessage is sent whenever the UTXO index had been updated.
 *
 * See: NotifyUtxosChangedRequestMessage
 */
export interface UtxosChangedNotificationMessage {
  added: RpcUtxosByAddressesEntry[];
  removed: RpcUtxosByAddressesEntry[];
}

export interface RpcUtxosByAddressesEntry {
  address: string;
  outpoint: RpcOutpoint | undefined;
  utxoEntry: RpcUtxoEntry | undefined;
}

/**
 * StopNotifyingUtxosChangedRequestMessage unregisters this connection for utxoChanged notifications
 * for the given addresses.
 *
 * This call is only available when this kaspad was started with `--utxoindex`
 *
 * See: UtxosChangedNotificationMessage
 *
 * This message only exists for backward compatibility reason with kaspad and is deprecated.
 * Use instead UtxosChangedNotificationMessage with command = NOTIFY_STOP.
 */
export interface StopNotifyingUtxosChangedRequestMessage {
  addresses: string[];
}

export interface StopNotifyingUtxosChangedResponseMessage {
  error: RPCError | undefined;
}

/**
 * GetUtxosByAddressesRequestMessage requests all current UTXOs for the given kaspad addresses
 *
 * This call is only available when this kaspad was started with `--utxoindex`
 */
export interface GetUtxosByAddressesRequestMessage {
  addresses: string[];
}

export interface GetUtxosByAddressesResponseMessage {
  entries: RpcUtxosByAddressesEntry[];
  error: RPCError | undefined;
}

/**
 * GetBalanceByAddressRequest returns the total balance in unspent transactions towards a given address
 *
 * This call is only available when this kaspad was started with `--utxoindex`
 */
export interface GetBalanceByAddressRequestMessage {
  address: string;
}

export interface GetBalanceByAddressResponseMessage {
  balance: number;
  error: RPCError | undefined;
}

export interface GetBalancesByAddressesRequestMessage {
  addresses: string[];
}

export interface RpcBalancesByAddressesEntry {
  address: string;
  balance: number;
  error: RPCError | undefined;
}

export interface GetBalancesByAddressesResponseMessage {
  entries: RpcBalancesByAddressesEntry[];
  error: RPCError | undefined;
}

/**
 * GetSinkBlueScoreRequestMessage requests the blue score of the current selected parent
 * of the virtual block.
 */
export interface GetSinkBlueScoreRequestMessage {}

export interface GetSinkBlueScoreResponseMessage {
  blueScore: number;
  error: RPCError | undefined;
}

/**
 * NotifySinkBlueScoreChangedRequestMessage registers this connection for
 * sinkBlueScoreChanged notifications.
 *
 * See: SinkBlueScoreChangedNotificationMessage
 */
export interface NotifySinkBlueScoreChangedRequestMessage {
  command: RpcNotifyCommand;
}

export interface NotifySinkBlueScoreChangedResponseMessage {
  error: RPCError | undefined;
}

/**
 * SinkBlueScoreChangedNotificationMessage is sent whenever the blue score
 * of the virtual's selected parent changes.
 *
 * See NotifySinkBlueScoreChangedRequestMessage
 */
export interface SinkBlueScoreChangedNotificationMessage {
  sinkBlueScore: number;
}

/**
 * NotifyVirtualDaaScoreChangedRequestMessage registers this connection for
 * virtualDaaScoreChanged notifications.
 *
 * See: VirtualDaaScoreChangedNotificationMessage
 */
export interface NotifyVirtualDaaScoreChangedRequestMessage {
  command: RpcNotifyCommand;
}

export interface NotifyVirtualDaaScoreChangedResponseMessage {
  error: RPCError | undefined;
}

/**
 * VirtualDaaScoreChangedNotificationMessage is sent whenever the DAA score
 * of the virtual changes.
 *
 * See NotifyVirtualDaaScoreChangedRequestMessage
 */
export interface VirtualDaaScoreChangedNotificationMessage {
  virtualDaaScore: number;
}

/**
 * NotifyPruningPointUtxoSetOverrideRequestMessage registers this connection for
 * pruning point UTXO set override notifications.
 *
 * This call is only available when this kaspad was started with `--utxoindex`
 *
 * See: NotifyPruningPointUtxoSetOverrideResponseMessage
 */
export interface NotifyPruningPointUtxoSetOverrideRequestMessage {
  command: RpcNotifyCommand;
}

export interface NotifyPruningPointUtxoSetOverrideResponseMessage {
  error: RPCError | undefined;
}

/**
 * PruningPointUtxoSetOverrideNotificationMessage is sent whenever the UTXO index
 * resets due to pruning point change via IBD.
 *
 * See NotifyPruningPointUtxoSetOverrideRequestMessage
 */
export interface PruningPointUtxoSetOverrideNotificationMessage {}

/**
 * StopNotifyingPruningPointUtxoSetOverrideRequestMessage unregisters this connection for
 * pruning point UTXO set override notifications.
 *
 * This call is only available when this kaspad was started with `--utxoindex`
 *
 * See: PruningPointUtxoSetOverrideNotificationMessage
 *
 * This message only exists for backward compatibility reason with kaspad and is deprecated.
 * Use instead NotifyPruningPointUtxoSetOverrideRequestMessage with command = NOTIFY_STOP.
 */
export interface StopNotifyingPruningPointUtxoSetOverrideRequestMessage {}

export interface StopNotifyingPruningPointUtxoSetOverrideResponseMessage {
  error: RPCError | undefined;
}

/** BanRequestMessage bans the given ip. */
export interface BanRequestMessage {
  ip: string;
}

export interface BanResponseMessage {
  error: RPCError | undefined;
}

/** UnbanRequestMessage unbans the given ip. */
export interface UnbanRequestMessage {
  ip: string;
}

export interface UnbanResponseMessage {
  error: RPCError | undefined;
}

/** GetInfoRequestMessage returns info about the node. */
export interface GetInfoRequestMessage {}

export interface GetInfoResponseMessage {
  p2pId: string;
  mempoolSize: number;
  serverVersion: string;
  isUtxoIndexed: boolean;
  isSynced: boolean;
  hasNotifyCommand: boolean;
  hasMessageId: boolean;
  error: RPCError | undefined;
}

export interface EstimateNetworkHashesPerSecondRequestMessage {
  windowSize: number;
  startHash: string;
}

export interface EstimateNetworkHashesPerSecondResponseMessage {
  networkHashesPerSecond: number;
  error: RPCError | undefined;
}

/**
 * NotifyNewBlockTemplateRequestMessage registers this connection for
 * NewBlockTemplate notifications.
 *
 * See: NewBlockTemplateNotificationMessage
 */
export interface NotifyNewBlockTemplateRequestMessage {
  command: RpcNotifyCommand;
}

export interface NotifyNewBlockTemplateResponseMessage {
  error: RPCError | undefined;
}

/**
 * NewBlockTemplateNotificationMessage is sent whenever a new updated block template is
 * available for miners.
 *
 * See NotifyNewBlockTemplateRequestMessage
 */
export interface NewBlockTemplateNotificationMessage {}

export interface RpcMempoolEntryByAddress {
  address: string;
  sending: RpcMempoolEntry[];
  receiving: RpcMempoolEntry[];
}

export interface GetMempoolEntriesByAddressesRequestMessage {
  addresses: string[];
  includeOrphanPool: boolean;
  filterTransactionPool: boolean;
}

export interface GetMempoolEntriesByAddressesResponseMessage {
  entries: RpcMempoolEntryByAddress[];
  error: RPCError | undefined;
}

export interface GetCoinSupplyRequestMessage {}

export interface GetCoinSupplyResponseMessage {
  /** note: this is a hard coded maxSupply, actual maxSupply is expected to deviate by upto -5%, but cannot be measured exactly. */
  maxSompi: number;
  circulatingSompi: number;
  error: RPCError | undefined;
}

export interface PingRequestMessage {}

export interface PingResponseMessage {
  error: RPCError | undefined;
}

export interface ProcessMetrics {
  residentSetSize: number;
  virtualMemorySize: number;
  coreNum: number;
  cpuUsage: number;
  fdNum: number;
  diskIoReadBytes: number;
  diskIoWriteBytes: number;
  diskIoReadPerSec: number;
  diskIoWritePerSec: number;
}

export interface ConnectionMetrics {
  borshLiveConnections: number;
  borshConnectionAttempts: number;
  borshHandshakeFailures: number;
  jsonLiveConnections: number;
  jsonConnectionAttempts: number;
  jsonHandshakeFailures: number;
  activePeers: number;
}

export interface BandwidthMetrics {
  borshBytesTx: number;
  borshBytesRx: number;
  jsonBytesTx: number;
  jsonBytesRx: number;
  grpcP2pBytesTx: number;
  grpcP2pBytesRx: number;
  grpcUserBytesTx: number;
  grpcUserBytesRx: number;
}

export interface ConsensusMetrics {
  blocksSubmitted: number;
  headerCounts: number;
  depCounts: number;
  bodyCounts: number;
  txsCounts: number;
  chainBlockCounts: number;
  massCounts: number;
  blockCount: number;
  headerCount: number;
  mempoolSize: number;
  tipHashesCount: number;
  difficulty: number;
  pastMedianTime: number;
  virtualParentHashesCount: number;
  virtualDaaScore: number;
}

export interface StorageMetrics {
  storageSizeBytes: number;
}

export interface GetConnectionsRequestMessage {
  includeProfileData: boolean;
}

export interface ConnectionsProfileData {
  cpuUsage: number;
  memoryUsage: number;
}

export interface GetConnectionsResponseMessage {
  clients: number;
  peers: number;
  profileData: ConnectionsProfileData | undefined;
  error: RPCError | undefined;
}

export interface GetSystemInfoRequestMessage {}

export interface GetSystemInfoResponseMessage {
  version: string;
  systemId: string;
  gitHash: string;
  coreNum: number;
  totalMemory: number;
  fdLimit: number;
  proxySocketLimitPerCpuCore: number;
  error: RPCError | undefined;
}

export interface GetMetricsRequestMessage {
  processMetrics: boolean;
  connectionMetrics: boolean;
  bandwidthMetrics: boolean;
  consensusMetrics: boolean;
  storageMetrics: boolean;
  customMetrics: boolean;
}

export interface GetMetricsResponseMessage {
  serverTime: number;
  processMetrics: ProcessMetrics | undefined;
  connectionMetrics: ConnectionMetrics | undefined;
  bandwidthMetrics: BandwidthMetrics | undefined;
  consensusMetrics: ConsensusMetrics | undefined;
  storageMetrics: StorageMetrics | undefined;
  error: RPCError | undefined;
}

export interface GetServerInfoRequestMessage {}

export interface GetServerInfoResponseMessage {
  rpcApiVersion: number;
  rpcApiRevision: number;
  serverVersion: string;
  networkId: string;
  hasUtxoIndex: boolean;
  isSynced: boolean;
  virtualDaaScore: number;
  error: RPCError | undefined;
}

export interface GetSyncStatusRequestMessage {}

export interface GetSyncStatusResponseMessage {
  isSynced: boolean;
  error: RPCError | undefined;
}

export interface GetDaaScoreTimestampEstimateRequestMessage {
  daaScores: number[];
}

export interface GetDaaScoreTimestampEstimateResponseMessage {
  timestamps: number[];
  error: RPCError | undefined;
}

export interface RpcFeerateBucket {
  /** Fee/mass of a transaction in `sompi/gram` units */
  feerate: number;
  estimatedSeconds: number;
}

/**
 * Data required for making fee estimates.
 *
 * Feerate values represent fee/mass of a transaction in `sompi/gram` units.
 * Given a feerate value recommendation, calculate the required fee by
 * taking the transaction mass and multiplying it by feerate: `fee = feerate * mass(tx)`
 */
export interface RpcFeeEstimate {
  /** Top-priority feerate bucket. Provides an estimation of the feerate required for sub-second DAG inclusion. */
  priorityBucket: RpcFeerateBucket | undefined;
  /**
   * A vector of *normal* priority feerate values. The first value of this vector is guaranteed to exist and
   * provide an estimation for sub-*minute* DAG inclusion. All other values will have shorter estimation
   * times than all `lowBucket` values. Therefor by chaining `[priority] | normal | low` and interpolating
   * between them, one can compose a complete feerate function on the client side. The API makes an effort
   * to sample enough "interesting" points on the feerate-to-time curve, so that the interpolation is meaningful.
   */
  normalBuckets: RpcFeerateBucket[];
  /**
   * A vector of *low* priority feerate values. The first value of this vector is guaranteed to
   * exist and provide an estimation for sub-*hour* DAG inclusion.
   */
  lowBuckets: RpcFeerateBucket[];
}

export interface RpcFeeEstimateVerboseExperimentalData {
  mempoolReadyTransactionsCount: number;
  mempoolReadyTransactionsTotalMass: number;
  networkMassPerSecond: number;
  nextBlockTemplateFeerateMin: number;
  nextBlockTemplateFeerateMedian: number;
  nextBlockTemplateFeerateMax: number;
}

export interface GetFeeEstimateRequestMessage {}

export interface GetFeeEstimateResponseMessage {
  estimate: RpcFeeEstimate | undefined;
  error: RPCError | undefined;
}

export interface GetFeeEstimateExperimentalRequestMessage {
  verbose: boolean;
}

export interface GetFeeEstimateExperimentalResponseMessage {
  estimate: RpcFeeEstimate | undefined;
  verbose: RpcFeeEstimateVerboseExperimentalData | undefined;
  error: RPCError | undefined;
}

export interface GetCurrentBlockColorRequestMessage {
  hash: string;
}

export interface GetCurrentBlockColorResponseMessage {
  blue: boolean;
  error: RPCError | undefined;
}

function createBaseRPCError(): RPCError {
  return { message: '' };
}

export const RPCError: MessageFns<RPCError> = {
  encode(message: RPCError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RPCError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRPCError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RPCError>): RPCError {
    return RPCError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RPCError>): RPCError {
    const message = createBaseRPCError();
    message.message = object.message ?? '';
    return message;
  }
};

function createBaseRpcBlock(): RpcBlock {
  return { header: undefined, transactions: [], verboseData: undefined };
}

export const RpcBlock: MessageFns<RpcBlock> = {
  encode(message: RpcBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RpcBlockHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    for (const v of message.transactions) {
      RpcTransaction.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.verboseData !== undefined) {
      RpcBlockVerboseData.encode(message.verboseData, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = RpcBlockHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactions.push(RpcTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verboseData = RpcBlockVerboseData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcBlock>): RpcBlock {
    return RpcBlock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcBlock>): RpcBlock {
    const message = createBaseRpcBlock();
    message.header =
      object.header !== undefined && object.header !== null ? RpcBlockHeader.fromPartial(object.header) : undefined;
    message.transactions = object.transactions?.map((e) => RpcTransaction.fromPartial(e)) || [];
    message.verboseData =
      object.verboseData !== undefined && object.verboseData !== null
        ? RpcBlockVerboseData.fromPartial(object.verboseData)
        : undefined;
    return message;
  }
};

function createBaseRpcBlockHeader(): RpcBlockHeader {
  return {
    version: 0,
    parents: [],
    hashMerkleRoot: '',
    acceptedIdMerkleRoot: '',
    utxoCommitment: '',
    timestamp: 0,
    bits: 0,
    nonce: 0,
    daaScore: 0,
    blueWork: '',
    pruningPoint: '',
    blueScore: 0
  };
}

export const RpcBlockHeader: MessageFns<RpcBlockHeader> = {
  encode(message: RpcBlockHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    for (const v of message.parents) {
      RpcBlockLevelParents.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.hashMerkleRoot !== '') {
      writer.uint32(26).string(message.hashMerkleRoot);
    }
    if (message.acceptedIdMerkleRoot !== '') {
      writer.uint32(34).string(message.acceptedIdMerkleRoot);
    }
    if (message.utxoCommitment !== '') {
      writer.uint32(42).string(message.utxoCommitment);
    }
    if (message.timestamp !== 0) {
      writer.uint32(48).int64(message.timestamp);
    }
    if (message.bits !== 0) {
      writer.uint32(56).uint32(message.bits);
    }
    if (message.nonce !== 0) {
      writer.uint32(64).uint64(message.nonce);
    }
    if (message.daaScore !== 0) {
      writer.uint32(72).uint64(message.daaScore);
    }
    if (message.blueWork !== '') {
      writer.uint32(82).string(message.blueWork);
    }
    if (message.pruningPoint !== '') {
      writer.uint32(114).string(message.pruningPoint);
    }
    if (message.blueScore !== 0) {
      writer.uint32(104).uint64(message.blueScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcBlockHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.parents.push(RpcBlockLevelParents.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hashMerkleRoot = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.acceptedIdMerkleRoot = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.utxoCommitment = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.bits = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.nonce = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.daaScore = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.blueWork = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.pruningPoint = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.blueScore = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcBlockHeader>): RpcBlockHeader {
    return RpcBlockHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcBlockHeader>): RpcBlockHeader {
    const message = createBaseRpcBlockHeader();
    message.version = object.version ?? 0;
    message.parents = object.parents?.map((e) => RpcBlockLevelParents.fromPartial(e)) || [];
    message.hashMerkleRoot = object.hashMerkleRoot ?? '';
    message.acceptedIdMerkleRoot = object.acceptedIdMerkleRoot ?? '';
    message.utxoCommitment = object.utxoCommitment ?? '';
    message.timestamp = object.timestamp ?? 0;
    message.bits = object.bits ?? 0;
    message.nonce = object.nonce ?? 0;
    message.daaScore = object.daaScore ?? 0;
    message.blueWork = object.blueWork ?? '';
    message.pruningPoint = object.pruningPoint ?? '';
    message.blueScore = object.blueScore ?? 0;
    return message;
  }
};

function createBaseRpcBlockLevelParents(): RpcBlockLevelParents {
  return { parentHashes: [] };
}

export const RpcBlockLevelParents: MessageFns<RpcBlockLevelParents> = {
  encode(message: RpcBlockLevelParents, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parentHashes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcBlockLevelParents {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcBlockLevelParents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parentHashes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcBlockLevelParents>): RpcBlockLevelParents {
    return RpcBlockLevelParents.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcBlockLevelParents>): RpcBlockLevelParents {
    const message = createBaseRpcBlockLevelParents();
    message.parentHashes = object.parentHashes?.map((e) => e) || [];
    return message;
  }
};

function createBaseRpcBlockVerboseData(): RpcBlockVerboseData {
  return {
    hash: '',
    difficulty: 0,
    selectedParentHash: '',
    transactionIds: [],
    isHeaderOnly: false,
    blueScore: 0,
    childrenHashes: [],
    mergeSetBluesHashes: [],
    mergeSetRedsHashes: [],
    isChainBlock: false
  };
}

export const RpcBlockVerboseData: MessageFns<RpcBlockVerboseData> = {
  encode(message: RpcBlockVerboseData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== '') {
      writer.uint32(10).string(message.hash);
    }
    if (message.difficulty !== 0) {
      writer.uint32(89).double(message.difficulty);
    }
    if (message.selectedParentHash !== '') {
      writer.uint32(106).string(message.selectedParentHash);
    }
    for (const v of message.transactionIds) {
      writer.uint32(114).string(v!);
    }
    if (message.isHeaderOnly !== false) {
      writer.uint32(120).bool(message.isHeaderOnly);
    }
    if (message.blueScore !== 0) {
      writer.uint32(128).uint64(message.blueScore);
    }
    for (const v of message.childrenHashes) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.mergeSetBluesHashes) {
      writer.uint32(146).string(v!);
    }
    for (const v of message.mergeSetRedsHashes) {
      writer.uint32(154).string(v!);
    }
    if (message.isChainBlock !== false) {
      writer.uint32(160).bool(message.isChainBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcBlockVerboseData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcBlockVerboseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.difficulty = reader.double();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.selectedParentHash = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.transactionIds.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isHeaderOnly = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.blueScore = longToNumber(reader.uint64());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.childrenHashes.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.mergeSetBluesHashes.push(reader.string());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.mergeSetRedsHashes.push(reader.string());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.isChainBlock = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcBlockVerboseData>): RpcBlockVerboseData {
    return RpcBlockVerboseData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcBlockVerboseData>): RpcBlockVerboseData {
    const message = createBaseRpcBlockVerboseData();
    message.hash = object.hash ?? '';
    message.difficulty = object.difficulty ?? 0;
    message.selectedParentHash = object.selectedParentHash ?? '';
    message.transactionIds = object.transactionIds?.map((e) => e) || [];
    message.isHeaderOnly = object.isHeaderOnly ?? false;
    message.blueScore = object.blueScore ?? 0;
    message.childrenHashes = object.childrenHashes?.map((e) => e) || [];
    message.mergeSetBluesHashes = object.mergeSetBluesHashes?.map((e) => e) || [];
    message.mergeSetRedsHashes = object.mergeSetRedsHashes?.map((e) => e) || [];
    message.isChainBlock = object.isChainBlock ?? false;
    return message;
  }
};

function createBaseRpcTransaction(): RpcTransaction {
  return {
    version: 0,
    inputs: [],
    outputs: [],
    lockTime: 0,
    subnetworkId: '',
    gas: 0,
    payload: '',
    verboseData: undefined,
    mass: 0
  };
}

export const RpcTransaction: MessageFns<RpcTransaction> = {
  encode(message: RpcTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    for (const v of message.inputs) {
      RpcTransactionInput.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.outputs) {
      RpcTransactionOutput.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.lockTime !== 0) {
      writer.uint32(32).uint64(message.lockTime);
    }
    if (message.subnetworkId !== '') {
      writer.uint32(42).string(message.subnetworkId);
    }
    if (message.gas !== 0) {
      writer.uint32(48).uint64(message.gas);
    }
    if (message.payload !== '') {
      writer.uint32(66).string(message.payload);
    }
    if (message.verboseData !== undefined) {
      RpcTransactionVerboseData.encode(message.verboseData, writer.uint32(74).fork()).join();
    }
    if (message.mass !== 0) {
      writer.uint32(80).uint64(message.mass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputs.push(RpcTransactionInput.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputs.push(RpcTransactionOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lockTime = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subnetworkId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gas = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.verboseData = RpcTransactionVerboseData.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.mass = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcTransaction>): RpcTransaction {
    return RpcTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcTransaction>): RpcTransaction {
    const message = createBaseRpcTransaction();
    message.version = object.version ?? 0;
    message.inputs = object.inputs?.map((e) => RpcTransactionInput.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => RpcTransactionOutput.fromPartial(e)) || [];
    message.lockTime = object.lockTime ?? 0;
    message.subnetworkId = object.subnetworkId ?? '';
    message.gas = object.gas ?? 0;
    message.payload = object.payload ?? '';
    message.verboseData =
      object.verboseData !== undefined && object.verboseData !== null
        ? RpcTransactionVerboseData.fromPartial(object.verboseData)
        : undefined;
    message.mass = object.mass ?? 0;
    return message;
  }
};

function createBaseRpcTransactionInput(): RpcTransactionInput {
  return { previousOutpoint: undefined, signatureScript: '', sequence: 0, sigOpCount: 0, verboseData: undefined };
}

export const RpcTransactionInput: MessageFns<RpcTransactionInput> = {
  encode(message: RpcTransactionInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.previousOutpoint !== undefined) {
      RpcOutpoint.encode(message.previousOutpoint, writer.uint32(10).fork()).join();
    }
    if (message.signatureScript !== '') {
      writer.uint32(18).string(message.signatureScript);
    }
    if (message.sequence !== 0) {
      writer.uint32(24).uint64(message.sequence);
    }
    if (message.sigOpCount !== 0) {
      writer.uint32(40).uint32(message.sigOpCount);
    }
    if (message.verboseData !== undefined) {
      RpcTransactionInputVerboseData.encode(message.verboseData, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcTransactionInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcTransactionInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.previousOutpoint = RpcOutpoint.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signatureScript = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sequence = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sigOpCount = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.verboseData = RpcTransactionInputVerboseData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcTransactionInput>): RpcTransactionInput {
    return RpcTransactionInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcTransactionInput>): RpcTransactionInput {
    const message = createBaseRpcTransactionInput();
    message.previousOutpoint =
      object.previousOutpoint !== undefined && object.previousOutpoint !== null
        ? RpcOutpoint.fromPartial(object.previousOutpoint)
        : undefined;
    message.signatureScript = object.signatureScript ?? '';
    message.sequence = object.sequence ?? 0;
    message.sigOpCount = object.sigOpCount ?? 0;
    message.verboseData =
      object.verboseData !== undefined && object.verboseData !== null
        ? RpcTransactionInputVerboseData.fromPartial(object.verboseData)
        : undefined;
    return message;
  }
};

function createBaseRpcScriptPublicKey(): RpcScriptPublicKey {
  return { version: 0, scriptPublicKey: '' };
}

export const RpcScriptPublicKey: MessageFns<RpcScriptPublicKey> = {
  encode(message: RpcScriptPublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.scriptPublicKey !== '') {
      writer.uint32(18).string(message.scriptPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcScriptPublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcScriptPublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scriptPublicKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcScriptPublicKey>): RpcScriptPublicKey {
    return RpcScriptPublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcScriptPublicKey>): RpcScriptPublicKey {
    const message = createBaseRpcScriptPublicKey();
    message.version = object.version ?? 0;
    message.scriptPublicKey = object.scriptPublicKey ?? '';
    return message;
  }
};

function createBaseRpcTransactionOutput(): RpcTransactionOutput {
  return { amount: 0, scriptPublicKey: undefined, verboseData: undefined };
}

export const RpcTransactionOutput: MessageFns<RpcTransactionOutput> = {
  encode(message: RpcTransactionOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== 0) {
      writer.uint32(8).uint64(message.amount);
    }
    if (message.scriptPublicKey !== undefined) {
      RpcScriptPublicKey.encode(message.scriptPublicKey, writer.uint32(18).fork()).join();
    }
    if (message.verboseData !== undefined) {
      RpcTransactionOutputVerboseData.encode(message.verboseData, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcTransactionOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcTransactionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amount = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scriptPublicKey = RpcScriptPublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verboseData = RpcTransactionOutputVerboseData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcTransactionOutput>): RpcTransactionOutput {
    return RpcTransactionOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcTransactionOutput>): RpcTransactionOutput {
    const message = createBaseRpcTransactionOutput();
    message.amount = object.amount ?? 0;
    message.scriptPublicKey =
      object.scriptPublicKey !== undefined && object.scriptPublicKey !== null
        ? RpcScriptPublicKey.fromPartial(object.scriptPublicKey)
        : undefined;
    message.verboseData =
      object.verboseData !== undefined && object.verboseData !== null
        ? RpcTransactionOutputVerboseData.fromPartial(object.verboseData)
        : undefined;
    return message;
  }
};

function createBaseRpcOutpoint(): RpcOutpoint {
  return { transactionId: '', index: 0 };
}

export const RpcOutpoint: MessageFns<RpcOutpoint> = {
  encode(message: RpcOutpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== '') {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcOutpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcOutpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcOutpoint>): RpcOutpoint {
    return RpcOutpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcOutpoint>): RpcOutpoint {
    const message = createBaseRpcOutpoint();
    message.transactionId = object.transactionId ?? '';
    message.index = object.index ?? 0;
    return message;
  }
};

function createBaseRpcUtxoEntry(): RpcUtxoEntry {
  return { amount: 0, scriptPublicKey: '', blockDaaScore: 0, isCoinbase: false };
}

export const RpcUtxoEntry: MessageFns<RpcUtxoEntry> = {
  encode(message: RpcUtxoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== 0) {
      writer.uint32(8).uint64(message.amount);
    }
    if (message.scriptPublicKey !== '') {
      writer.uint32(18).string(message.scriptPublicKey);
    }
    if (message.blockDaaScore !== 0) {
      writer.uint32(24).uint64(message.blockDaaScore);
    }
    if (message.isCoinbase !== false) {
      writer.uint32(32).bool(message.isCoinbase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcUtxoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcUtxoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amount = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scriptPublicKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blockDaaScore = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isCoinbase = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcUtxoEntry>): RpcUtxoEntry {
    return RpcUtxoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcUtxoEntry>): RpcUtxoEntry {
    const message = createBaseRpcUtxoEntry();
    message.amount = object.amount ?? 0;
    message.scriptPublicKey = object.scriptPublicKey ?? '';
    message.blockDaaScore = object.blockDaaScore ?? 0;
    message.isCoinbase = object.isCoinbase ?? false;
    return message;
  }
};

function createBaseRpcTransactionVerboseData(): RpcTransactionVerboseData {
  return { transactionId: '', hash: '', computeMass: 0, blockHash: '', blockTime: 0 };
}

export const RpcTransactionVerboseData: MessageFns<RpcTransactionVerboseData> = {
  encode(message: RpcTransactionVerboseData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== '') {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.hash !== '') {
      writer.uint32(18).string(message.hash);
    }
    if (message.computeMass !== 0) {
      writer.uint32(32).uint64(message.computeMass);
    }
    if (message.blockHash !== '') {
      writer.uint32(98).string(message.blockHash);
    }
    if (message.blockTime !== 0) {
      writer.uint32(112).uint64(message.blockTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcTransactionVerboseData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcTransactionVerboseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.computeMass = longToNumber(reader.uint64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.blockTime = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcTransactionVerboseData>): RpcTransactionVerboseData {
    return RpcTransactionVerboseData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcTransactionVerboseData>): RpcTransactionVerboseData {
    const message = createBaseRpcTransactionVerboseData();
    message.transactionId = object.transactionId ?? '';
    message.hash = object.hash ?? '';
    message.computeMass = object.computeMass ?? 0;
    message.blockHash = object.blockHash ?? '';
    message.blockTime = object.blockTime ?? 0;
    return message;
  }
};

function createBaseRpcTransactionInputVerboseData(): RpcTransactionInputVerboseData {
  return {};
}

export const RpcTransactionInputVerboseData: MessageFns<RpcTransactionInputVerboseData> = {
  encode(_: RpcTransactionInputVerboseData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcTransactionInputVerboseData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcTransactionInputVerboseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcTransactionInputVerboseData>): RpcTransactionInputVerboseData {
    return RpcTransactionInputVerboseData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RpcTransactionInputVerboseData>): RpcTransactionInputVerboseData {
    const message = createBaseRpcTransactionInputVerboseData();
    return message;
  }
};

function createBaseRpcTransactionOutputVerboseData(): RpcTransactionOutputVerboseData {
  return { scriptPublicKeyType: '', scriptPublicKeyAddress: '' };
}

export const RpcTransactionOutputVerboseData: MessageFns<RpcTransactionOutputVerboseData> = {
  encode(message: RpcTransactionOutputVerboseData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scriptPublicKeyType !== '') {
      writer.uint32(42).string(message.scriptPublicKeyType);
    }
    if (message.scriptPublicKeyAddress !== '') {
      writer.uint32(50).string(message.scriptPublicKeyAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcTransactionOutputVerboseData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcTransactionOutputVerboseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scriptPublicKeyType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scriptPublicKeyAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcTransactionOutputVerboseData>): RpcTransactionOutputVerboseData {
    return RpcTransactionOutputVerboseData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcTransactionOutputVerboseData>): RpcTransactionOutputVerboseData {
    const message = createBaseRpcTransactionOutputVerboseData();
    message.scriptPublicKeyType = object.scriptPublicKeyType ?? '';
    message.scriptPublicKeyAddress = object.scriptPublicKeyAddress ?? '';
    return message;
  }
};

function createBaseGetCurrentNetworkRequestMessage(): GetCurrentNetworkRequestMessage {
  return {};
}

export const GetCurrentNetworkRequestMessage: MessageFns<GetCurrentNetworkRequestMessage> = {
  encode(_: GetCurrentNetworkRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentNetworkRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentNetworkRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetCurrentNetworkRequestMessage>): GetCurrentNetworkRequestMessage {
    return GetCurrentNetworkRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetCurrentNetworkRequestMessage>): GetCurrentNetworkRequestMessage {
    const message = createBaseGetCurrentNetworkRequestMessage();
    return message;
  }
};

function createBaseGetCurrentNetworkResponseMessage(): GetCurrentNetworkResponseMessage {
  return { currentNetwork: '', error: undefined };
}

export const GetCurrentNetworkResponseMessage: MessageFns<GetCurrentNetworkResponseMessage> = {
  encode(message: GetCurrentNetworkResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentNetwork !== '') {
      writer.uint32(10).string(message.currentNetwork);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentNetworkResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentNetworkResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currentNetwork = reader.string();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetCurrentNetworkResponseMessage>): GetCurrentNetworkResponseMessage {
    return GetCurrentNetworkResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrentNetworkResponseMessage>): GetCurrentNetworkResponseMessage {
    const message = createBaseGetCurrentNetworkResponseMessage();
    message.currentNetwork = object.currentNetwork ?? '';
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseSubmitBlockRequestMessage(): SubmitBlockRequestMessage {
  return { block: undefined, allowNonDAABlocks: false };
}

export const SubmitBlockRequestMessage: MessageFns<SubmitBlockRequestMessage> = {
  encode(message: SubmitBlockRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      RpcBlock.encode(message.block, writer.uint32(18).fork()).join();
    }
    if (message.allowNonDAABlocks !== false) {
      writer.uint32(24).bool(message.allowNonDAABlocks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitBlockRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitBlockRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.block = RpcBlock.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allowNonDAABlocks = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubmitBlockRequestMessage>): SubmitBlockRequestMessage {
    return SubmitBlockRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitBlockRequestMessage>): SubmitBlockRequestMessage {
    const message = createBaseSubmitBlockRequestMessage();
    message.block =
      object.block !== undefined && object.block !== null ? RpcBlock.fromPartial(object.block) : undefined;
    message.allowNonDAABlocks = object.allowNonDAABlocks ?? false;
    return message;
  }
};

function createBaseSubmitBlockResponseMessage(): SubmitBlockResponseMessage {
  return { rejectReason: 0, error: undefined };
}

export const SubmitBlockResponseMessage: MessageFns<SubmitBlockResponseMessage> = {
  encode(message: SubmitBlockResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rejectReason !== 0) {
      writer.uint32(8).int32(message.rejectReason);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitBlockResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitBlockResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rejectReason = reader.int32() as any;
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubmitBlockResponseMessage>): SubmitBlockResponseMessage {
    return SubmitBlockResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitBlockResponseMessage>): SubmitBlockResponseMessage {
    const message = createBaseSubmitBlockResponseMessage();
    message.rejectReason = object.rejectReason ?? 0;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetBlockTemplateRequestMessage(): GetBlockTemplateRequestMessage {
  return { payAddress: '', extraData: '' };
}

export const GetBlockTemplateRequestMessage: MessageFns<GetBlockTemplateRequestMessage> = {
  encode(message: GetBlockTemplateRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payAddress !== '') {
      writer.uint32(10).string(message.payAddress);
    }
    if (message.extraData !== '') {
      writer.uint32(18).string(message.extraData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockTemplateRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockTemplateRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extraData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlockTemplateRequestMessage>): GetBlockTemplateRequestMessage {
    return GetBlockTemplateRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockTemplateRequestMessage>): GetBlockTemplateRequestMessage {
    const message = createBaseGetBlockTemplateRequestMessage();
    message.payAddress = object.payAddress ?? '';
    message.extraData = object.extraData ?? '';
    return message;
  }
};

function createBaseGetBlockTemplateResponseMessage(): GetBlockTemplateResponseMessage {
  return { block: undefined, isSynced: false, error: undefined };
}

export const GetBlockTemplateResponseMessage: MessageFns<GetBlockTemplateResponseMessage> = {
  encode(message: GetBlockTemplateResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      RpcBlock.encode(message.block, writer.uint32(26).fork()).join();
    }
    if (message.isSynced !== false) {
      writer.uint32(16).bool(message.isSynced);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockTemplateResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockTemplateResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.block = RpcBlock.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSynced = reader.bool();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlockTemplateResponseMessage>): GetBlockTemplateResponseMessage {
    return GetBlockTemplateResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockTemplateResponseMessage>): GetBlockTemplateResponseMessage {
    const message = createBaseGetBlockTemplateResponseMessage();
    message.block =
      object.block !== undefined && object.block !== null ? RpcBlock.fromPartial(object.block) : undefined;
    message.isSynced = object.isSynced ?? false;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseNotifyBlockAddedRequestMessage(): NotifyBlockAddedRequestMessage {
  return { command: 0 };
}

export const NotifyBlockAddedRequestMessage: MessageFns<NotifyBlockAddedRequestMessage> = {
  encode(message: NotifyBlockAddedRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== 0) {
      writer.uint32(808).int32(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyBlockAddedRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyBlockAddedRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 101: {
          if (tag !== 808) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyBlockAddedRequestMessage>): NotifyBlockAddedRequestMessage {
    return NotifyBlockAddedRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyBlockAddedRequestMessage>): NotifyBlockAddedRequestMessage {
    const message = createBaseNotifyBlockAddedRequestMessage();
    message.command = object.command ?? 0;
    return message;
  }
};

function createBaseNotifyBlockAddedResponseMessage(): NotifyBlockAddedResponseMessage {
  return { error: undefined };
}

export const NotifyBlockAddedResponseMessage: MessageFns<NotifyBlockAddedResponseMessage> = {
  encode(message: NotifyBlockAddedResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyBlockAddedResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyBlockAddedResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyBlockAddedResponseMessage>): NotifyBlockAddedResponseMessage {
    return NotifyBlockAddedResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyBlockAddedResponseMessage>): NotifyBlockAddedResponseMessage {
    const message = createBaseNotifyBlockAddedResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseBlockAddedNotificationMessage(): BlockAddedNotificationMessage {
  return { block: undefined };
}

export const BlockAddedNotificationMessage: MessageFns<BlockAddedNotificationMessage> = {
  encode(message: BlockAddedNotificationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      RpcBlock.encode(message.block, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockAddedNotificationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockAddedNotificationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.block = RpcBlock.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BlockAddedNotificationMessage>): BlockAddedNotificationMessage {
    return BlockAddedNotificationMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockAddedNotificationMessage>): BlockAddedNotificationMessage {
    const message = createBaseBlockAddedNotificationMessage();
    message.block =
      object.block !== undefined && object.block !== null ? RpcBlock.fromPartial(object.block) : undefined;
    return message;
  }
};

function createBaseGetPeerAddressesRequestMessage(): GetPeerAddressesRequestMessage {
  return {};
}

export const GetPeerAddressesRequestMessage: MessageFns<GetPeerAddressesRequestMessage> = {
  encode(_: GetPeerAddressesRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPeerAddressesRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPeerAddressesRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetPeerAddressesRequestMessage>): GetPeerAddressesRequestMessage {
    return GetPeerAddressesRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetPeerAddressesRequestMessage>): GetPeerAddressesRequestMessage {
    const message = createBaseGetPeerAddressesRequestMessage();
    return message;
  }
};

function createBaseGetPeerAddressesResponseMessage(): GetPeerAddressesResponseMessage {
  return { addresses: [], bannedAddresses: [], error: undefined };
}

export const GetPeerAddressesResponseMessage: MessageFns<GetPeerAddressesResponseMessage> = {
  encode(message: GetPeerAddressesResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      GetPeerAddressesKnownAddressMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.bannedAddresses) {
      GetPeerAddressesKnownAddressMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPeerAddressesResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPeerAddressesResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(GetPeerAddressesKnownAddressMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bannedAddresses.push(GetPeerAddressesKnownAddressMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetPeerAddressesResponseMessage>): GetPeerAddressesResponseMessage {
    return GetPeerAddressesResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPeerAddressesResponseMessage>): GetPeerAddressesResponseMessage {
    const message = createBaseGetPeerAddressesResponseMessage();
    message.addresses = object.addresses?.map((e) => GetPeerAddressesKnownAddressMessage.fromPartial(e)) || [];
    message.bannedAddresses =
      object.bannedAddresses?.map((e) => GetPeerAddressesKnownAddressMessage.fromPartial(e)) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetPeerAddressesKnownAddressMessage(): GetPeerAddressesKnownAddressMessage {
  return { Addr: '' };
}

export const GetPeerAddressesKnownAddressMessage: MessageFns<GetPeerAddressesKnownAddressMessage> = {
  encode(message: GetPeerAddressesKnownAddressMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Addr !== '') {
      writer.uint32(10).string(message.Addr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPeerAddressesKnownAddressMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPeerAddressesKnownAddressMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Addr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetPeerAddressesKnownAddressMessage>): GetPeerAddressesKnownAddressMessage {
    return GetPeerAddressesKnownAddressMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPeerAddressesKnownAddressMessage>): GetPeerAddressesKnownAddressMessage {
    const message = createBaseGetPeerAddressesKnownAddressMessage();
    message.Addr = object.Addr ?? '';
    return message;
  }
};

function createBaseGetSinkRequestMessage(): GetSinkRequestMessage {
  return {};
}

export const GetSinkRequestMessage: MessageFns<GetSinkRequestMessage> = {
  encode(_: GetSinkRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSinkRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSinkRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSinkRequestMessage>): GetSinkRequestMessage {
    return GetSinkRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetSinkRequestMessage>): GetSinkRequestMessage {
    const message = createBaseGetSinkRequestMessage();
    return message;
  }
};

function createBaseGetSinkResponseMessage(): GetSinkResponseMessage {
  return { sink: '', error: undefined };
}

export const GetSinkResponseMessage: MessageFns<GetSinkResponseMessage> = {
  encode(message: GetSinkResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sink !== '') {
      writer.uint32(10).string(message.sink);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSinkResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSinkResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sink = reader.string();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSinkResponseMessage>): GetSinkResponseMessage {
    return GetSinkResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSinkResponseMessage>): GetSinkResponseMessage {
    const message = createBaseGetSinkResponseMessage();
    message.sink = object.sink ?? '';
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetMempoolEntryRequestMessage(): GetMempoolEntryRequestMessage {
  return { txId: '', includeOrphanPool: false, filterTransactionPool: false };
}

export const GetMempoolEntryRequestMessage: MessageFns<GetMempoolEntryRequestMessage> = {
  encode(message: GetMempoolEntryRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txId !== '') {
      writer.uint32(10).string(message.txId);
    }
    if (message.includeOrphanPool !== false) {
      writer.uint32(16).bool(message.includeOrphanPool);
    }
    if (message.filterTransactionPool !== false) {
      writer.uint32(24).bool(message.filterTransactionPool);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolEntryRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolEntryRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeOrphanPool = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.filterTransactionPool = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMempoolEntryRequestMessage>): GetMempoolEntryRequestMessage {
    return GetMempoolEntryRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMempoolEntryRequestMessage>): GetMempoolEntryRequestMessage {
    const message = createBaseGetMempoolEntryRequestMessage();
    message.txId = object.txId ?? '';
    message.includeOrphanPool = object.includeOrphanPool ?? false;
    message.filterTransactionPool = object.filterTransactionPool ?? false;
    return message;
  }
};

function createBaseGetMempoolEntryResponseMessage(): GetMempoolEntryResponseMessage {
  return { entry: undefined, error: undefined };
}

export const GetMempoolEntryResponseMessage: MessageFns<GetMempoolEntryResponseMessage> = {
  encode(message: GetMempoolEntryResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entry !== undefined) {
      RpcMempoolEntry.encode(message.entry, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolEntryResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolEntryResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry = RpcMempoolEntry.decode(reader, reader.uint32());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMempoolEntryResponseMessage>): GetMempoolEntryResponseMessage {
    return GetMempoolEntryResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMempoolEntryResponseMessage>): GetMempoolEntryResponseMessage {
    const message = createBaseGetMempoolEntryResponseMessage();
    message.entry =
      object.entry !== undefined && object.entry !== null ? RpcMempoolEntry.fromPartial(object.entry) : undefined;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetMempoolEntriesRequestMessage(): GetMempoolEntriesRequestMessage {
  return { includeOrphanPool: false, filterTransactionPool: false };
}

export const GetMempoolEntriesRequestMessage: MessageFns<GetMempoolEntriesRequestMessage> = {
  encode(message: GetMempoolEntriesRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeOrphanPool !== false) {
      writer.uint32(8).bool(message.includeOrphanPool);
    }
    if (message.filterTransactionPool !== false) {
      writer.uint32(16).bool(message.filterTransactionPool);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolEntriesRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolEntriesRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.includeOrphanPool = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.filterTransactionPool = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMempoolEntriesRequestMessage>): GetMempoolEntriesRequestMessage {
    return GetMempoolEntriesRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMempoolEntriesRequestMessage>): GetMempoolEntriesRequestMessage {
    const message = createBaseGetMempoolEntriesRequestMessage();
    message.includeOrphanPool = object.includeOrphanPool ?? false;
    message.filterTransactionPool = object.filterTransactionPool ?? false;
    return message;
  }
};

function createBaseGetMempoolEntriesResponseMessage(): GetMempoolEntriesResponseMessage {
  return { entries: [], error: undefined };
}

export const GetMempoolEntriesResponseMessage: MessageFns<GetMempoolEntriesResponseMessage> = {
  encode(message: GetMempoolEntriesResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      RpcMempoolEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolEntriesResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolEntriesResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(RpcMempoolEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMempoolEntriesResponseMessage>): GetMempoolEntriesResponseMessage {
    return GetMempoolEntriesResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMempoolEntriesResponseMessage>): GetMempoolEntriesResponseMessage {
    const message = createBaseGetMempoolEntriesResponseMessage();
    message.entries = object.entries?.map((e) => RpcMempoolEntry.fromPartial(e)) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseRpcMempoolEntry(): RpcMempoolEntry {
  return { fee: 0, transaction: undefined, isOrphan: false };
}

export const RpcMempoolEntry: MessageFns<RpcMempoolEntry> = {
  encode(message: RpcMempoolEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== 0) {
      writer.uint32(8).uint64(message.fee);
    }
    if (message.transaction !== undefined) {
      RpcTransaction.encode(message.transaction, writer.uint32(26).fork()).join();
    }
    if (message.isOrphan !== false) {
      writer.uint32(32).bool(message.isOrphan);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcMempoolEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcMempoolEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fee = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transaction = RpcTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isOrphan = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcMempoolEntry>): RpcMempoolEntry {
    return RpcMempoolEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcMempoolEntry>): RpcMempoolEntry {
    const message = createBaseRpcMempoolEntry();
    message.fee = object.fee ?? 0;
    message.transaction =
      object.transaction !== undefined && object.transaction !== null
        ? RpcTransaction.fromPartial(object.transaction)
        : undefined;
    message.isOrphan = object.isOrphan ?? false;
    return message;
  }
};

function createBaseGetConnectedPeerInfoRequestMessage(): GetConnectedPeerInfoRequestMessage {
  return {};
}

export const GetConnectedPeerInfoRequestMessage: MessageFns<GetConnectedPeerInfoRequestMessage> = {
  encode(_: GetConnectedPeerInfoRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectedPeerInfoRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedPeerInfoRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetConnectedPeerInfoRequestMessage>): GetConnectedPeerInfoRequestMessage {
    return GetConnectedPeerInfoRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetConnectedPeerInfoRequestMessage>): GetConnectedPeerInfoRequestMessage {
    const message = createBaseGetConnectedPeerInfoRequestMessage();
    return message;
  }
};

function createBaseGetConnectedPeerInfoResponseMessage(): GetConnectedPeerInfoResponseMessage {
  return { infos: [], error: undefined };
}

export const GetConnectedPeerInfoResponseMessage: MessageFns<GetConnectedPeerInfoResponseMessage> = {
  encode(message: GetConnectedPeerInfoResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.infos) {
      GetConnectedPeerInfoMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectedPeerInfoResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedPeerInfoResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.infos.push(GetConnectedPeerInfoMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetConnectedPeerInfoResponseMessage>): GetConnectedPeerInfoResponseMessage {
    return GetConnectedPeerInfoResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectedPeerInfoResponseMessage>): GetConnectedPeerInfoResponseMessage {
    const message = createBaseGetConnectedPeerInfoResponseMessage();
    message.infos = object.infos?.map((e) => GetConnectedPeerInfoMessage.fromPartial(e)) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetConnectedPeerInfoMessage(): GetConnectedPeerInfoMessage {
  return {
    id: '',
    address: '',
    lastPingDuration: 0,
    isOutbound: false,
    timeOffset: 0,
    userAgent: '',
    advertisedProtocolVersion: 0,
    timeConnected: 0,
    isIbdPeer: false
  };
}

export const GetConnectedPeerInfoMessage: MessageFns<GetConnectedPeerInfoMessage> = {
  encode(message: GetConnectedPeerInfoMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.address !== '') {
      writer.uint32(18).string(message.address);
    }
    if (message.lastPingDuration !== 0) {
      writer.uint32(24).int64(message.lastPingDuration);
    }
    if (message.isOutbound !== false) {
      writer.uint32(48).bool(message.isOutbound);
    }
    if (message.timeOffset !== 0) {
      writer.uint32(56).int64(message.timeOffset);
    }
    if (message.userAgent !== '') {
      writer.uint32(66).string(message.userAgent);
    }
    if (message.advertisedProtocolVersion !== 0) {
      writer.uint32(72).uint32(message.advertisedProtocolVersion);
    }
    if (message.timeConnected !== 0) {
      writer.uint32(80).int64(message.timeConnected);
    }
    if (message.isIbdPeer !== false) {
      writer.uint32(88).bool(message.isIbdPeer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectedPeerInfoMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedPeerInfoMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lastPingDuration = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isOutbound = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timeOffset = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.advertisedProtocolVersion = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.timeConnected = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isIbdPeer = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetConnectedPeerInfoMessage>): GetConnectedPeerInfoMessage {
    return GetConnectedPeerInfoMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectedPeerInfoMessage>): GetConnectedPeerInfoMessage {
    const message = createBaseGetConnectedPeerInfoMessage();
    message.id = object.id ?? '';
    message.address = object.address ?? '';
    message.lastPingDuration = object.lastPingDuration ?? 0;
    message.isOutbound = object.isOutbound ?? false;
    message.timeOffset = object.timeOffset ?? 0;
    message.userAgent = object.userAgent ?? '';
    message.advertisedProtocolVersion = object.advertisedProtocolVersion ?? 0;
    message.timeConnected = object.timeConnected ?? 0;
    message.isIbdPeer = object.isIbdPeer ?? false;
    return message;
  }
};

function createBaseAddPeerRequestMessage(): AddPeerRequestMessage {
  return { address: '', isPermanent: false };
}

export const AddPeerRequestMessage: MessageFns<AddPeerRequestMessage> = {
  encode(message: AddPeerRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== '') {
      writer.uint32(10).string(message.address);
    }
    if (message.isPermanent !== false) {
      writer.uint32(16).bool(message.isPermanent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddPeerRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddPeerRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isPermanent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AddPeerRequestMessage>): AddPeerRequestMessage {
    return AddPeerRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddPeerRequestMessage>): AddPeerRequestMessage {
    const message = createBaseAddPeerRequestMessage();
    message.address = object.address ?? '';
    message.isPermanent = object.isPermanent ?? false;
    return message;
  }
};

function createBaseAddPeerResponseMessage(): AddPeerResponseMessage {
  return { error: undefined };
}

export const AddPeerResponseMessage: MessageFns<AddPeerResponseMessage> = {
  encode(message: AddPeerResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddPeerResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddPeerResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AddPeerResponseMessage>): AddPeerResponseMessage {
    return AddPeerResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddPeerResponseMessage>): AddPeerResponseMessage {
    const message = createBaseAddPeerResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseSubmitTransactionRequestMessage(): SubmitTransactionRequestMessage {
  return { transaction: undefined, allowOrphan: false };
}

export const SubmitTransactionRequestMessage: MessageFns<SubmitTransactionRequestMessage> = {
  encode(message: SubmitTransactionRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      RpcTransaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    if (message.allowOrphan !== false) {
      writer.uint32(16).bool(message.allowOrphan);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = RpcTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allowOrphan = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubmitTransactionRequestMessage>): SubmitTransactionRequestMessage {
    return SubmitTransactionRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitTransactionRequestMessage>): SubmitTransactionRequestMessage {
    const message = createBaseSubmitTransactionRequestMessage();
    message.transaction =
      object.transaction !== undefined && object.transaction !== null
        ? RpcTransaction.fromPartial(object.transaction)
        : undefined;
    message.allowOrphan = object.allowOrphan ?? false;
    return message;
  }
};

function createBaseSubmitTransactionResponseMessage(): SubmitTransactionResponseMessage {
  return { transactionId: '', error: undefined };
}

export const SubmitTransactionResponseMessage: MessageFns<SubmitTransactionResponseMessage> = {
  encode(message: SubmitTransactionResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== '') {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubmitTransactionResponseMessage>): SubmitTransactionResponseMessage {
    return SubmitTransactionResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitTransactionResponseMessage>): SubmitTransactionResponseMessage {
    const message = createBaseSubmitTransactionResponseMessage();
    message.transactionId = object.transactionId ?? '';
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseSubmitTransactionReplacementRequestMessage(): SubmitTransactionReplacementRequestMessage {
  return { transaction: undefined };
}

export const SubmitTransactionReplacementRequestMessage: MessageFns<SubmitTransactionReplacementRequestMessage> = {
  encode(message: SubmitTransactionReplacementRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      RpcTransaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionReplacementRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionReplacementRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = RpcTransaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubmitTransactionReplacementRequestMessage>): SubmitTransactionReplacementRequestMessage {
    return SubmitTransactionReplacementRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SubmitTransactionReplacementRequestMessage>
  ): SubmitTransactionReplacementRequestMessage {
    const message = createBaseSubmitTransactionReplacementRequestMessage();
    message.transaction =
      object.transaction !== undefined && object.transaction !== null
        ? RpcTransaction.fromPartial(object.transaction)
        : undefined;
    return message;
  }
};

function createBaseSubmitTransactionReplacementResponseMessage(): SubmitTransactionReplacementResponseMessage {
  return { transactionId: '', replacedTransaction: undefined, error: undefined };
}

export const SubmitTransactionReplacementResponseMessage: MessageFns<SubmitTransactionReplacementResponseMessage> = {
  encode(
    message: SubmitTransactionReplacementResponseMessage,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.transactionId !== '') {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.replacedTransaction !== undefined) {
      RpcTransaction.encode(message.replacedTransaction, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionReplacementResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionReplacementResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.replacedTransaction = RpcTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubmitTransactionReplacementResponseMessage>): SubmitTransactionReplacementResponseMessage {
    return SubmitTransactionReplacementResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SubmitTransactionReplacementResponseMessage>
  ): SubmitTransactionReplacementResponseMessage {
    const message = createBaseSubmitTransactionReplacementResponseMessage();
    message.transactionId = object.transactionId ?? '';
    message.replacedTransaction =
      object.replacedTransaction !== undefined && object.replacedTransaction !== null
        ? RpcTransaction.fromPartial(object.replacedTransaction)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseNotifyVirtualChainChangedRequestMessage(): NotifyVirtualChainChangedRequestMessage {
  return { includeAcceptedTransactionIds: false, command: 0 };
}

export const NotifyVirtualChainChangedRequestMessage: MessageFns<NotifyVirtualChainChangedRequestMessage> = {
  encode(message: NotifyVirtualChainChangedRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeAcceptedTransactionIds !== false) {
      writer.uint32(8).bool(message.includeAcceptedTransactionIds);
    }
    if (message.command !== 0) {
      writer.uint32(808).int32(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyVirtualChainChangedRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyVirtualChainChangedRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.includeAcceptedTransactionIds = reader.bool();
          continue;
        }
        case 101: {
          if (tag !== 808) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyVirtualChainChangedRequestMessage>): NotifyVirtualChainChangedRequestMessage {
    return NotifyVirtualChainChangedRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyVirtualChainChangedRequestMessage>): NotifyVirtualChainChangedRequestMessage {
    const message = createBaseNotifyVirtualChainChangedRequestMessage();
    message.includeAcceptedTransactionIds = object.includeAcceptedTransactionIds ?? false;
    message.command = object.command ?? 0;
    return message;
  }
};

function createBaseNotifyVirtualChainChangedResponseMessage(): NotifyVirtualChainChangedResponseMessage {
  return { error: undefined };
}

export const NotifyVirtualChainChangedResponseMessage: MessageFns<NotifyVirtualChainChangedResponseMessage> = {
  encode(message: NotifyVirtualChainChangedResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyVirtualChainChangedResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyVirtualChainChangedResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyVirtualChainChangedResponseMessage>): NotifyVirtualChainChangedResponseMessage {
    return NotifyVirtualChainChangedResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyVirtualChainChangedResponseMessage>): NotifyVirtualChainChangedResponseMessage {
    const message = createBaseNotifyVirtualChainChangedResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseVirtualChainChangedNotificationMessage(): VirtualChainChangedNotificationMessage {
  return { removedChainBlockHashes: [], addedChainBlockHashes: [], acceptedTransactionIds: [] };
}

export const VirtualChainChangedNotificationMessage: MessageFns<VirtualChainChangedNotificationMessage> = {
  encode(message: VirtualChainChangedNotificationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.removedChainBlockHashes) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.addedChainBlockHashes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.acceptedTransactionIds) {
      RpcAcceptedTransactionIds.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualChainChangedNotificationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualChainChangedNotificationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.removedChainBlockHashes.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addedChainBlockHashes.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.acceptedTransactionIds.push(RpcAcceptedTransactionIds.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<VirtualChainChangedNotificationMessage>): VirtualChainChangedNotificationMessage {
    return VirtualChainChangedNotificationMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VirtualChainChangedNotificationMessage>): VirtualChainChangedNotificationMessage {
    const message = createBaseVirtualChainChangedNotificationMessage();
    message.removedChainBlockHashes = object.removedChainBlockHashes?.map((e) => e) || [];
    message.addedChainBlockHashes = object.addedChainBlockHashes?.map((e) => e) || [];
    message.acceptedTransactionIds =
      object.acceptedTransactionIds?.map((e) => RpcAcceptedTransactionIds.fromPartial(e)) || [];
    return message;
  }
};

function createBaseGetBlockRequestMessage(): GetBlockRequestMessage {
  return { hash: '', includeTransactions: false };
}

export const GetBlockRequestMessage: MessageFns<GetBlockRequestMessage> = {
  encode(message: GetBlockRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== '') {
      writer.uint32(10).string(message.hash);
    }
    if (message.includeTransactions !== false) {
      writer.uint32(24).bool(message.includeTransactions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeTransactions = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlockRequestMessage>): GetBlockRequestMessage {
    return GetBlockRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockRequestMessage>): GetBlockRequestMessage {
    const message = createBaseGetBlockRequestMessage();
    message.hash = object.hash ?? '';
    message.includeTransactions = object.includeTransactions ?? false;
    return message;
  }
};

function createBaseGetBlockResponseMessage(): GetBlockResponseMessage {
  return { block: undefined, error: undefined };
}

export const GetBlockResponseMessage: MessageFns<GetBlockResponseMessage> = {
  encode(message: GetBlockResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      RpcBlock.encode(message.block, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.block = RpcBlock.decode(reader, reader.uint32());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlockResponseMessage>): GetBlockResponseMessage {
    return GetBlockResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockResponseMessage>): GetBlockResponseMessage {
    const message = createBaseGetBlockResponseMessage();
    message.block =
      object.block !== undefined && object.block !== null ? RpcBlock.fromPartial(object.block) : undefined;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetSubnetworkRequestMessage(): GetSubnetworkRequestMessage {
  return { subnetworkId: '' };
}

export const GetSubnetworkRequestMessage: MessageFns<GetSubnetworkRequestMessage> = {
  encode(message: GetSubnetworkRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subnetworkId !== '') {
      writer.uint32(10).string(message.subnetworkId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubnetworkRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubnetworkRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subnetworkId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSubnetworkRequestMessage>): GetSubnetworkRequestMessage {
    return GetSubnetworkRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSubnetworkRequestMessage>): GetSubnetworkRequestMessage {
    const message = createBaseGetSubnetworkRequestMessage();
    message.subnetworkId = object.subnetworkId ?? '';
    return message;
  }
};

function createBaseGetSubnetworkResponseMessage(): GetSubnetworkResponseMessage {
  return { gasLimit: 0, error: undefined };
}

export const GetSubnetworkResponseMessage: MessageFns<GetSubnetworkResponseMessage> = {
  encode(message: GetSubnetworkResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gasLimit !== 0) {
      writer.uint32(8).uint64(message.gasLimit);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubnetworkResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubnetworkResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSubnetworkResponseMessage>): GetSubnetworkResponseMessage {
    return GetSubnetworkResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSubnetworkResponseMessage>): GetSubnetworkResponseMessage {
    const message = createBaseGetSubnetworkResponseMessage();
    message.gasLimit = object.gasLimit ?? 0;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetVirtualChainFromBlockRequestMessage(): GetVirtualChainFromBlockRequestMessage {
  return { startHash: '', includeAcceptedTransactionIds: false };
}

export const GetVirtualChainFromBlockRequestMessage: MessageFns<GetVirtualChainFromBlockRequestMessage> = {
  encode(message: GetVirtualChainFromBlockRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startHash !== '') {
      writer.uint32(10).string(message.startHash);
    }
    if (message.includeAcceptedTransactionIds !== false) {
      writer.uint32(16).bool(message.includeAcceptedTransactionIds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVirtualChainFromBlockRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVirtualChainFromBlockRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeAcceptedTransactionIds = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetVirtualChainFromBlockRequestMessage>): GetVirtualChainFromBlockRequestMessage {
    return GetVirtualChainFromBlockRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVirtualChainFromBlockRequestMessage>): GetVirtualChainFromBlockRequestMessage {
    const message = createBaseGetVirtualChainFromBlockRequestMessage();
    message.startHash = object.startHash ?? '';
    message.includeAcceptedTransactionIds = object.includeAcceptedTransactionIds ?? false;
    return message;
  }
};

function createBaseRpcAcceptedTransactionIds(): RpcAcceptedTransactionIds {
  return { acceptingBlockHash: '', acceptedTransactionIds: [] };
}

export const RpcAcceptedTransactionIds: MessageFns<RpcAcceptedTransactionIds> = {
  encode(message: RpcAcceptedTransactionIds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.acceptingBlockHash !== '') {
      writer.uint32(10).string(message.acceptingBlockHash);
    }
    for (const v of message.acceptedTransactionIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcAcceptedTransactionIds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcAcceptedTransactionIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.acceptingBlockHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.acceptedTransactionIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcAcceptedTransactionIds>): RpcAcceptedTransactionIds {
    return RpcAcceptedTransactionIds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcAcceptedTransactionIds>): RpcAcceptedTransactionIds {
    const message = createBaseRpcAcceptedTransactionIds();
    message.acceptingBlockHash = object.acceptingBlockHash ?? '';
    message.acceptedTransactionIds = object.acceptedTransactionIds?.map((e) => e) || [];
    return message;
  }
};

function createBaseGetVirtualChainFromBlockResponseMessage(): GetVirtualChainFromBlockResponseMessage {
  return { removedChainBlockHashes: [], addedChainBlockHashes: [], acceptedTransactionIds: [], error: undefined };
}

export const GetVirtualChainFromBlockResponseMessage: MessageFns<GetVirtualChainFromBlockResponseMessage> = {
  encode(message: GetVirtualChainFromBlockResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.removedChainBlockHashes) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.addedChainBlockHashes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.acceptedTransactionIds) {
      RpcAcceptedTransactionIds.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVirtualChainFromBlockResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVirtualChainFromBlockResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.removedChainBlockHashes.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addedChainBlockHashes.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.acceptedTransactionIds.push(RpcAcceptedTransactionIds.decode(reader, reader.uint32()));
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetVirtualChainFromBlockResponseMessage>): GetVirtualChainFromBlockResponseMessage {
    return GetVirtualChainFromBlockResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVirtualChainFromBlockResponseMessage>): GetVirtualChainFromBlockResponseMessage {
    const message = createBaseGetVirtualChainFromBlockResponseMessage();
    message.removedChainBlockHashes = object.removedChainBlockHashes?.map((e) => e) || [];
    message.addedChainBlockHashes = object.addedChainBlockHashes?.map((e) => e) || [];
    message.acceptedTransactionIds =
      object.acceptedTransactionIds?.map((e) => RpcAcceptedTransactionIds.fromPartial(e)) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetBlocksRequestMessage(): GetBlocksRequestMessage {
  return { lowHash: '', includeBlocks: false, includeTransactions: false };
}

export const GetBlocksRequestMessage: MessageFns<GetBlocksRequestMessage> = {
  encode(message: GetBlocksRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lowHash !== '') {
      writer.uint32(10).string(message.lowHash);
    }
    if (message.includeBlocks !== false) {
      writer.uint32(16).bool(message.includeBlocks);
    }
    if (message.includeTransactions !== false) {
      writer.uint32(24).bool(message.includeTransactions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlocksRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlocksRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lowHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeBlocks = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeTransactions = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlocksRequestMessage>): GetBlocksRequestMessage {
    return GetBlocksRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlocksRequestMessage>): GetBlocksRequestMessage {
    const message = createBaseGetBlocksRequestMessage();
    message.lowHash = object.lowHash ?? '';
    message.includeBlocks = object.includeBlocks ?? false;
    message.includeTransactions = object.includeTransactions ?? false;
    return message;
  }
};

function createBaseGetBlocksResponseMessage(): GetBlocksResponseMessage {
  return { blockHashes: [], blocks: [], error: undefined };
}

export const GetBlocksResponseMessage: MessageFns<GetBlocksResponseMessage> = {
  encode(message: GetBlocksResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blockHashes) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.blocks) {
      RpcBlock.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlocksResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlocksResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.blockHashes.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blocks.push(RpcBlock.decode(reader, reader.uint32()));
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlocksResponseMessage>): GetBlocksResponseMessage {
    return GetBlocksResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlocksResponseMessage>): GetBlocksResponseMessage {
    const message = createBaseGetBlocksResponseMessage();
    message.blockHashes = object.blockHashes?.map((e) => e) || [];
    message.blocks = object.blocks?.map((e) => RpcBlock.fromPartial(e)) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetBlockCountRequestMessage(): GetBlockCountRequestMessage {
  return {};
}

export const GetBlockCountRequestMessage: MessageFns<GetBlockCountRequestMessage> = {
  encode(_: GetBlockCountRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockCountRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockCountRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlockCountRequestMessage>): GetBlockCountRequestMessage {
    return GetBlockCountRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetBlockCountRequestMessage>): GetBlockCountRequestMessage {
    const message = createBaseGetBlockCountRequestMessage();
    return message;
  }
};

function createBaseGetBlockCountResponseMessage(): GetBlockCountResponseMessage {
  return { blockCount: 0, headerCount: 0, error: undefined };
}

export const GetBlockCountResponseMessage: MessageFns<GetBlockCountResponseMessage> = {
  encode(message: GetBlockCountResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockCount !== 0) {
      writer.uint32(8).uint64(message.blockCount);
    }
    if (message.headerCount !== 0) {
      writer.uint32(16).uint64(message.headerCount);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockCountResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockCountResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockCount = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.headerCount = longToNumber(reader.uint64());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlockCountResponseMessage>): GetBlockCountResponseMessage {
    return GetBlockCountResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockCountResponseMessage>): GetBlockCountResponseMessage {
    const message = createBaseGetBlockCountResponseMessage();
    message.blockCount = object.blockCount ?? 0;
    message.headerCount = object.headerCount ?? 0;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetBlockDagInfoRequestMessage(): GetBlockDagInfoRequestMessage {
  return {};
}

export const GetBlockDagInfoRequestMessage: MessageFns<GetBlockDagInfoRequestMessage> = {
  encode(_: GetBlockDagInfoRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockDagInfoRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockDagInfoRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlockDagInfoRequestMessage>): GetBlockDagInfoRequestMessage {
    return GetBlockDagInfoRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetBlockDagInfoRequestMessage>): GetBlockDagInfoRequestMessage {
    const message = createBaseGetBlockDagInfoRequestMessage();
    return message;
  }
};

function createBaseGetBlockDagInfoResponseMessage(): GetBlockDagInfoResponseMessage {
  return {
    networkName: '',
    blockCount: 0,
    headerCount: 0,
    tipHashes: [],
    difficulty: 0,
    pastMedianTime: 0,
    virtualParentHashes: [],
    pruningPointHash: '',
    virtualDaaScore: 0,
    sink: '',
    error: undefined
  };
}

export const GetBlockDagInfoResponseMessage: MessageFns<GetBlockDagInfoResponseMessage> = {
  encode(message: GetBlockDagInfoResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkName !== '') {
      writer.uint32(10).string(message.networkName);
    }
    if (message.blockCount !== 0) {
      writer.uint32(16).uint64(message.blockCount);
    }
    if (message.headerCount !== 0) {
      writer.uint32(24).uint64(message.headerCount);
    }
    for (const v of message.tipHashes) {
      writer.uint32(34).string(v!);
    }
    if (message.difficulty !== 0) {
      writer.uint32(41).double(message.difficulty);
    }
    if (message.pastMedianTime !== 0) {
      writer.uint32(48).int64(message.pastMedianTime);
    }
    for (const v of message.virtualParentHashes) {
      writer.uint32(58).string(v!);
    }
    if (message.pruningPointHash !== '') {
      writer.uint32(66).string(message.pruningPointHash);
    }
    if (message.virtualDaaScore !== 0) {
      writer.uint32(72).uint64(message.virtualDaaScore);
    }
    if (message.sink !== '') {
      writer.uint32(82).string(message.sink);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockDagInfoResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockDagInfoResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.networkName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockCount = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.headerCount = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tipHashes.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.difficulty = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pastMedianTime = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.virtualParentHashes.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pruningPointHash = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.virtualDaaScore = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sink = reader.string();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlockDagInfoResponseMessage>): GetBlockDagInfoResponseMessage {
    return GetBlockDagInfoResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockDagInfoResponseMessage>): GetBlockDagInfoResponseMessage {
    const message = createBaseGetBlockDagInfoResponseMessage();
    message.networkName = object.networkName ?? '';
    message.blockCount = object.blockCount ?? 0;
    message.headerCount = object.headerCount ?? 0;
    message.tipHashes = object.tipHashes?.map((e) => e) || [];
    message.difficulty = object.difficulty ?? 0;
    message.pastMedianTime = object.pastMedianTime ?? 0;
    message.virtualParentHashes = object.virtualParentHashes?.map((e) => e) || [];
    message.pruningPointHash = object.pruningPointHash ?? '';
    message.virtualDaaScore = object.virtualDaaScore ?? 0;
    message.sink = object.sink ?? '';
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseResolveFinalityConflictRequestMessage(): ResolveFinalityConflictRequestMessage {
  return { finalityBlockHash: '' };
}

export const ResolveFinalityConflictRequestMessage: MessageFns<ResolveFinalityConflictRequestMessage> = {
  encode(message: ResolveFinalityConflictRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalityBlockHash !== '') {
      writer.uint32(10).string(message.finalityBlockHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveFinalityConflictRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveFinalityConflictRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalityBlockHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ResolveFinalityConflictRequestMessage>): ResolveFinalityConflictRequestMessage {
    return ResolveFinalityConflictRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResolveFinalityConflictRequestMessage>): ResolveFinalityConflictRequestMessage {
    const message = createBaseResolveFinalityConflictRequestMessage();
    message.finalityBlockHash = object.finalityBlockHash ?? '';
    return message;
  }
};

function createBaseResolveFinalityConflictResponseMessage(): ResolveFinalityConflictResponseMessage {
  return { error: undefined };
}

export const ResolveFinalityConflictResponseMessage: MessageFns<ResolveFinalityConflictResponseMessage> = {
  encode(message: ResolveFinalityConflictResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveFinalityConflictResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveFinalityConflictResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ResolveFinalityConflictResponseMessage>): ResolveFinalityConflictResponseMessage {
    return ResolveFinalityConflictResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResolveFinalityConflictResponseMessage>): ResolveFinalityConflictResponseMessage {
    const message = createBaseResolveFinalityConflictResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseNotifyFinalityConflictRequestMessage(): NotifyFinalityConflictRequestMessage {
  return { command: 0 };
}

export const NotifyFinalityConflictRequestMessage: MessageFns<NotifyFinalityConflictRequestMessage> = {
  encode(message: NotifyFinalityConflictRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== 0) {
      writer.uint32(808).int32(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyFinalityConflictRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyFinalityConflictRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 101: {
          if (tag !== 808) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyFinalityConflictRequestMessage>): NotifyFinalityConflictRequestMessage {
    return NotifyFinalityConflictRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyFinalityConflictRequestMessage>): NotifyFinalityConflictRequestMessage {
    const message = createBaseNotifyFinalityConflictRequestMessage();
    message.command = object.command ?? 0;
    return message;
  }
};

function createBaseNotifyFinalityConflictResponseMessage(): NotifyFinalityConflictResponseMessage {
  return { error: undefined };
}

export const NotifyFinalityConflictResponseMessage: MessageFns<NotifyFinalityConflictResponseMessage> = {
  encode(message: NotifyFinalityConflictResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyFinalityConflictResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyFinalityConflictResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyFinalityConflictResponseMessage>): NotifyFinalityConflictResponseMessage {
    return NotifyFinalityConflictResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyFinalityConflictResponseMessage>): NotifyFinalityConflictResponseMessage {
    const message = createBaseNotifyFinalityConflictResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseFinalityConflictNotificationMessage(): FinalityConflictNotificationMessage {
  return { violatingBlockHash: '' };
}

export const FinalityConflictNotificationMessage: MessageFns<FinalityConflictNotificationMessage> = {
  encode(message: FinalityConflictNotificationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.violatingBlockHash !== '') {
      writer.uint32(10).string(message.violatingBlockHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalityConflictNotificationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalityConflictNotificationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.violatingBlockHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FinalityConflictNotificationMessage>): FinalityConflictNotificationMessage {
    return FinalityConflictNotificationMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalityConflictNotificationMessage>): FinalityConflictNotificationMessage {
    const message = createBaseFinalityConflictNotificationMessage();
    message.violatingBlockHash = object.violatingBlockHash ?? '';
    return message;
  }
};

function createBaseFinalityConflictResolvedNotificationMessage(): FinalityConflictResolvedNotificationMessage {
  return { finalityBlockHash: '' };
}

export const FinalityConflictResolvedNotificationMessage: MessageFns<FinalityConflictResolvedNotificationMessage> = {
  encode(
    message: FinalityConflictResolvedNotificationMessage,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.finalityBlockHash !== '') {
      writer.uint32(10).string(message.finalityBlockHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalityConflictResolvedNotificationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalityConflictResolvedNotificationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalityBlockHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FinalityConflictResolvedNotificationMessage>): FinalityConflictResolvedNotificationMessage {
    return FinalityConflictResolvedNotificationMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FinalityConflictResolvedNotificationMessage>
  ): FinalityConflictResolvedNotificationMessage {
    const message = createBaseFinalityConflictResolvedNotificationMessage();
    message.finalityBlockHash = object.finalityBlockHash ?? '';
    return message;
  }
};

function createBaseShutdownRequestMessage(): ShutdownRequestMessage {
  return {};
}

export const ShutdownRequestMessage: MessageFns<ShutdownRequestMessage> = {
  encode(_: ShutdownRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShutdownRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShutdownRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ShutdownRequestMessage>): ShutdownRequestMessage {
    return ShutdownRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ShutdownRequestMessage>): ShutdownRequestMessage {
    const message = createBaseShutdownRequestMessage();
    return message;
  }
};

function createBaseShutdownResponseMessage(): ShutdownResponseMessage {
  return { error: undefined };
}

export const ShutdownResponseMessage: MessageFns<ShutdownResponseMessage> = {
  encode(message: ShutdownResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShutdownResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShutdownResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ShutdownResponseMessage>): ShutdownResponseMessage {
    return ShutdownResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShutdownResponseMessage>): ShutdownResponseMessage {
    const message = createBaseShutdownResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetHeadersRequestMessage(): GetHeadersRequestMessage {
  return { startHash: '', limit: 0, isAscending: false };
}

export const GetHeadersRequestMessage: MessageFns<GetHeadersRequestMessage> = {
  encode(message: GetHeadersRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startHash !== '') {
      writer.uint32(10).string(message.startHash);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint64(message.limit);
    }
    if (message.isAscending !== false) {
      writer.uint32(24).bool(message.isAscending);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHeadersRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHeadersRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isAscending = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetHeadersRequestMessage>): GetHeadersRequestMessage {
    return GetHeadersRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHeadersRequestMessage>): GetHeadersRequestMessage {
    const message = createBaseGetHeadersRequestMessage();
    message.startHash = object.startHash ?? '';
    message.limit = object.limit ?? 0;
    message.isAscending = object.isAscending ?? false;
    return message;
  }
};

function createBaseGetHeadersResponseMessage(): GetHeadersResponseMessage {
  return { headers: [], error: undefined };
}

export const GetHeadersResponseMessage: MessageFns<GetHeadersResponseMessage> = {
  encode(message: GetHeadersResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.headers) {
      writer.uint32(10).string(v!);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHeadersResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHeadersResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.headers.push(reader.string());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetHeadersResponseMessage>): GetHeadersResponseMessage {
    return GetHeadersResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHeadersResponseMessage>): GetHeadersResponseMessage {
    const message = createBaseGetHeadersResponseMessage();
    message.headers = object.headers?.map((e) => e) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseNotifyUtxosChangedRequestMessage(): NotifyUtxosChangedRequestMessage {
  return { addresses: [], command: 0 };
}

export const NotifyUtxosChangedRequestMessage: MessageFns<NotifyUtxosChangedRequestMessage> = {
  encode(message: NotifyUtxosChangedRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      writer.uint32(10).string(v!);
    }
    if (message.command !== 0) {
      writer.uint32(808).int32(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyUtxosChangedRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyUtxosChangedRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        }
        case 101: {
          if (tag !== 808) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyUtxosChangedRequestMessage>): NotifyUtxosChangedRequestMessage {
    return NotifyUtxosChangedRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyUtxosChangedRequestMessage>): NotifyUtxosChangedRequestMessage {
    const message = createBaseNotifyUtxosChangedRequestMessage();
    message.addresses = object.addresses?.map((e) => e) || [];
    message.command = object.command ?? 0;
    return message;
  }
};

function createBaseNotifyUtxosChangedResponseMessage(): NotifyUtxosChangedResponseMessage {
  return { error: undefined };
}

export const NotifyUtxosChangedResponseMessage: MessageFns<NotifyUtxosChangedResponseMessage> = {
  encode(message: NotifyUtxosChangedResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyUtxosChangedResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyUtxosChangedResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyUtxosChangedResponseMessage>): NotifyUtxosChangedResponseMessage {
    return NotifyUtxosChangedResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyUtxosChangedResponseMessage>): NotifyUtxosChangedResponseMessage {
    const message = createBaseNotifyUtxosChangedResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseUtxosChangedNotificationMessage(): UtxosChangedNotificationMessage {
  return { added: [], removed: [] };
}

export const UtxosChangedNotificationMessage: MessageFns<UtxosChangedNotificationMessage> = {
  encode(message: UtxosChangedNotificationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.added) {
      RpcUtxosByAddressesEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.removed) {
      RpcUtxosByAddressesEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UtxosChangedNotificationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUtxosChangedNotificationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.added.push(RpcUtxosByAddressesEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.removed.push(RpcUtxosByAddressesEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UtxosChangedNotificationMessage>): UtxosChangedNotificationMessage {
    return UtxosChangedNotificationMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UtxosChangedNotificationMessage>): UtxosChangedNotificationMessage {
    const message = createBaseUtxosChangedNotificationMessage();
    message.added = object.added?.map((e) => RpcUtxosByAddressesEntry.fromPartial(e)) || [];
    message.removed = object.removed?.map((e) => RpcUtxosByAddressesEntry.fromPartial(e)) || [];
    return message;
  }
};

function createBaseRpcUtxosByAddressesEntry(): RpcUtxosByAddressesEntry {
  return { address: '', outpoint: undefined, utxoEntry: undefined };
}

export const RpcUtxosByAddressesEntry: MessageFns<RpcUtxosByAddressesEntry> = {
  encode(message: RpcUtxosByAddressesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== '') {
      writer.uint32(10).string(message.address);
    }
    if (message.outpoint !== undefined) {
      RpcOutpoint.encode(message.outpoint, writer.uint32(18).fork()).join();
    }
    if (message.utxoEntry !== undefined) {
      RpcUtxoEntry.encode(message.utxoEntry, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcUtxosByAddressesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcUtxosByAddressesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outpoint = RpcOutpoint.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.utxoEntry = RpcUtxoEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcUtxosByAddressesEntry>): RpcUtxosByAddressesEntry {
    return RpcUtxosByAddressesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcUtxosByAddressesEntry>): RpcUtxosByAddressesEntry {
    const message = createBaseRpcUtxosByAddressesEntry();
    message.address = object.address ?? '';
    message.outpoint =
      object.outpoint !== undefined && object.outpoint !== null ? RpcOutpoint.fromPartial(object.outpoint) : undefined;
    message.utxoEntry =
      object.utxoEntry !== undefined && object.utxoEntry !== null
        ? RpcUtxoEntry.fromPartial(object.utxoEntry)
        : undefined;
    return message;
  }
};

function createBaseStopNotifyingUtxosChangedRequestMessage(): StopNotifyingUtxosChangedRequestMessage {
  return { addresses: [] };
}

export const StopNotifyingUtxosChangedRequestMessage: MessageFns<StopNotifyingUtxosChangedRequestMessage> = {
  encode(message: StopNotifyingUtxosChangedRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopNotifyingUtxosChangedRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopNotifyingUtxosChangedRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StopNotifyingUtxosChangedRequestMessage>): StopNotifyingUtxosChangedRequestMessage {
    return StopNotifyingUtxosChangedRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopNotifyingUtxosChangedRequestMessage>): StopNotifyingUtxosChangedRequestMessage {
    const message = createBaseStopNotifyingUtxosChangedRequestMessage();
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  }
};

function createBaseStopNotifyingUtxosChangedResponseMessage(): StopNotifyingUtxosChangedResponseMessage {
  return { error: undefined };
}

export const StopNotifyingUtxosChangedResponseMessage: MessageFns<StopNotifyingUtxosChangedResponseMessage> = {
  encode(message: StopNotifyingUtxosChangedResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopNotifyingUtxosChangedResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopNotifyingUtxosChangedResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StopNotifyingUtxosChangedResponseMessage>): StopNotifyingUtxosChangedResponseMessage {
    return StopNotifyingUtxosChangedResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopNotifyingUtxosChangedResponseMessage>): StopNotifyingUtxosChangedResponseMessage {
    const message = createBaseStopNotifyingUtxosChangedResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetUtxosByAddressesRequestMessage(): GetUtxosByAddressesRequestMessage {
  return { addresses: [] };
}

export const GetUtxosByAddressesRequestMessage: MessageFns<GetUtxosByAddressesRequestMessage> = {
  encode(message: GetUtxosByAddressesRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUtxosByAddressesRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUtxosByAddressesRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetUtxosByAddressesRequestMessage>): GetUtxosByAddressesRequestMessage {
    return GetUtxosByAddressesRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUtxosByAddressesRequestMessage>): GetUtxosByAddressesRequestMessage {
    const message = createBaseGetUtxosByAddressesRequestMessage();
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  }
};

function createBaseGetUtxosByAddressesResponseMessage(): GetUtxosByAddressesResponseMessage {
  return { entries: [], error: undefined };
}

export const GetUtxosByAddressesResponseMessage: MessageFns<GetUtxosByAddressesResponseMessage> = {
  encode(message: GetUtxosByAddressesResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      RpcUtxosByAddressesEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUtxosByAddressesResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUtxosByAddressesResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(RpcUtxosByAddressesEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetUtxosByAddressesResponseMessage>): GetUtxosByAddressesResponseMessage {
    return GetUtxosByAddressesResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUtxosByAddressesResponseMessage>): GetUtxosByAddressesResponseMessage {
    const message = createBaseGetUtxosByAddressesResponseMessage();
    message.entries = object.entries?.map((e) => RpcUtxosByAddressesEntry.fromPartial(e)) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetBalanceByAddressRequestMessage(): GetBalanceByAddressRequestMessage {
  return { address: '' };
}

export const GetBalanceByAddressRequestMessage: MessageFns<GetBalanceByAddressRequestMessage> = {
  encode(message: GetBalanceByAddressRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== '') {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceByAddressRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceByAddressRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBalanceByAddressRequestMessage>): GetBalanceByAddressRequestMessage {
    return GetBalanceByAddressRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBalanceByAddressRequestMessage>): GetBalanceByAddressRequestMessage {
    const message = createBaseGetBalanceByAddressRequestMessage();
    message.address = object.address ?? '';
    return message;
  }
};

function createBaseGetBalanceByAddressResponseMessage(): GetBalanceByAddressResponseMessage {
  return { balance: 0, error: undefined };
}

export const GetBalanceByAddressResponseMessage: MessageFns<GetBalanceByAddressResponseMessage> = {
  encode(message: GetBalanceByAddressResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== 0) {
      writer.uint32(8).uint64(message.balance);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceByAddressResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceByAddressResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.balance = longToNumber(reader.uint64());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBalanceByAddressResponseMessage>): GetBalanceByAddressResponseMessage {
    return GetBalanceByAddressResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBalanceByAddressResponseMessage>): GetBalanceByAddressResponseMessage {
    const message = createBaseGetBalanceByAddressResponseMessage();
    message.balance = object.balance ?? 0;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetBalancesByAddressesRequestMessage(): GetBalancesByAddressesRequestMessage {
  return { addresses: [] };
}

export const GetBalancesByAddressesRequestMessage: MessageFns<GetBalancesByAddressesRequestMessage> = {
  encode(message: GetBalancesByAddressesRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalancesByAddressesRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalancesByAddressesRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBalancesByAddressesRequestMessage>): GetBalancesByAddressesRequestMessage {
    return GetBalancesByAddressesRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBalancesByAddressesRequestMessage>): GetBalancesByAddressesRequestMessage {
    const message = createBaseGetBalancesByAddressesRequestMessage();
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  }
};

function createBaseRpcBalancesByAddressesEntry(): RpcBalancesByAddressesEntry {
  return { address: '', balance: 0, error: undefined };
}

export const RpcBalancesByAddressesEntry: MessageFns<RpcBalancesByAddressesEntry> = {
  encode(message: RpcBalancesByAddressesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== '') {
      writer.uint32(10).string(message.address);
    }
    if (message.balance !== 0) {
      writer.uint32(16).uint64(message.balance);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcBalancesByAddressesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcBalancesByAddressesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.balance = longToNumber(reader.uint64());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcBalancesByAddressesEntry>): RpcBalancesByAddressesEntry {
    return RpcBalancesByAddressesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcBalancesByAddressesEntry>): RpcBalancesByAddressesEntry {
    const message = createBaseRpcBalancesByAddressesEntry();
    message.address = object.address ?? '';
    message.balance = object.balance ?? 0;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetBalancesByAddressesResponseMessage(): GetBalancesByAddressesResponseMessage {
  return { entries: [], error: undefined };
}

export const GetBalancesByAddressesResponseMessage: MessageFns<GetBalancesByAddressesResponseMessage> = {
  encode(message: GetBalancesByAddressesResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      RpcBalancesByAddressesEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalancesByAddressesResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalancesByAddressesResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(RpcBalancesByAddressesEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBalancesByAddressesResponseMessage>): GetBalancesByAddressesResponseMessage {
    return GetBalancesByAddressesResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBalancesByAddressesResponseMessage>): GetBalancesByAddressesResponseMessage {
    const message = createBaseGetBalancesByAddressesResponseMessage();
    message.entries = object.entries?.map((e) => RpcBalancesByAddressesEntry.fromPartial(e)) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetSinkBlueScoreRequestMessage(): GetSinkBlueScoreRequestMessage {
  return {};
}

export const GetSinkBlueScoreRequestMessage: MessageFns<GetSinkBlueScoreRequestMessage> = {
  encode(_: GetSinkBlueScoreRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSinkBlueScoreRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSinkBlueScoreRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSinkBlueScoreRequestMessage>): GetSinkBlueScoreRequestMessage {
    return GetSinkBlueScoreRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetSinkBlueScoreRequestMessage>): GetSinkBlueScoreRequestMessage {
    const message = createBaseGetSinkBlueScoreRequestMessage();
    return message;
  }
};

function createBaseGetSinkBlueScoreResponseMessage(): GetSinkBlueScoreResponseMessage {
  return { blueScore: 0, error: undefined };
}

export const GetSinkBlueScoreResponseMessage: MessageFns<GetSinkBlueScoreResponseMessage> = {
  encode(message: GetSinkBlueScoreResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueScore !== 0) {
      writer.uint32(8).uint64(message.blueScore);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSinkBlueScoreResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSinkBlueScoreResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blueScore = longToNumber(reader.uint64());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSinkBlueScoreResponseMessage>): GetSinkBlueScoreResponseMessage {
    return GetSinkBlueScoreResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSinkBlueScoreResponseMessage>): GetSinkBlueScoreResponseMessage {
    const message = createBaseGetSinkBlueScoreResponseMessage();
    message.blueScore = object.blueScore ?? 0;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseNotifySinkBlueScoreChangedRequestMessage(): NotifySinkBlueScoreChangedRequestMessage {
  return { command: 0 };
}

export const NotifySinkBlueScoreChangedRequestMessage: MessageFns<NotifySinkBlueScoreChangedRequestMessage> = {
  encode(message: NotifySinkBlueScoreChangedRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== 0) {
      writer.uint32(808).int32(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifySinkBlueScoreChangedRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifySinkBlueScoreChangedRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 101: {
          if (tag !== 808) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifySinkBlueScoreChangedRequestMessage>): NotifySinkBlueScoreChangedRequestMessage {
    return NotifySinkBlueScoreChangedRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifySinkBlueScoreChangedRequestMessage>): NotifySinkBlueScoreChangedRequestMessage {
    const message = createBaseNotifySinkBlueScoreChangedRequestMessage();
    message.command = object.command ?? 0;
    return message;
  }
};

function createBaseNotifySinkBlueScoreChangedResponseMessage(): NotifySinkBlueScoreChangedResponseMessage {
  return { error: undefined };
}

export const NotifySinkBlueScoreChangedResponseMessage: MessageFns<NotifySinkBlueScoreChangedResponseMessage> = {
  encode(message: NotifySinkBlueScoreChangedResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifySinkBlueScoreChangedResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifySinkBlueScoreChangedResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifySinkBlueScoreChangedResponseMessage>): NotifySinkBlueScoreChangedResponseMessage {
    return NotifySinkBlueScoreChangedResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<NotifySinkBlueScoreChangedResponseMessage>
  ): NotifySinkBlueScoreChangedResponseMessage {
    const message = createBaseNotifySinkBlueScoreChangedResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseSinkBlueScoreChangedNotificationMessage(): SinkBlueScoreChangedNotificationMessage {
  return { sinkBlueScore: 0 };
}

export const SinkBlueScoreChangedNotificationMessage: MessageFns<SinkBlueScoreChangedNotificationMessage> = {
  encode(message: SinkBlueScoreChangedNotificationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sinkBlueScore !== 0) {
      writer.uint32(8).uint64(message.sinkBlueScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinkBlueScoreChangedNotificationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinkBlueScoreChangedNotificationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sinkBlueScore = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SinkBlueScoreChangedNotificationMessage>): SinkBlueScoreChangedNotificationMessage {
    return SinkBlueScoreChangedNotificationMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SinkBlueScoreChangedNotificationMessage>): SinkBlueScoreChangedNotificationMessage {
    const message = createBaseSinkBlueScoreChangedNotificationMessage();
    message.sinkBlueScore = object.sinkBlueScore ?? 0;
    return message;
  }
};

function createBaseNotifyVirtualDaaScoreChangedRequestMessage(): NotifyVirtualDaaScoreChangedRequestMessage {
  return { command: 0 };
}

export const NotifyVirtualDaaScoreChangedRequestMessage: MessageFns<NotifyVirtualDaaScoreChangedRequestMessage> = {
  encode(message: NotifyVirtualDaaScoreChangedRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== 0) {
      writer.uint32(808).int32(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyVirtualDaaScoreChangedRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyVirtualDaaScoreChangedRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 101: {
          if (tag !== 808) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyVirtualDaaScoreChangedRequestMessage>): NotifyVirtualDaaScoreChangedRequestMessage {
    return NotifyVirtualDaaScoreChangedRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<NotifyVirtualDaaScoreChangedRequestMessage>
  ): NotifyVirtualDaaScoreChangedRequestMessage {
    const message = createBaseNotifyVirtualDaaScoreChangedRequestMessage();
    message.command = object.command ?? 0;
    return message;
  }
};

function createBaseNotifyVirtualDaaScoreChangedResponseMessage(): NotifyVirtualDaaScoreChangedResponseMessage {
  return { error: undefined };
}

export const NotifyVirtualDaaScoreChangedResponseMessage: MessageFns<NotifyVirtualDaaScoreChangedResponseMessage> = {
  encode(
    message: NotifyVirtualDaaScoreChangedResponseMessage,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyVirtualDaaScoreChangedResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyVirtualDaaScoreChangedResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyVirtualDaaScoreChangedResponseMessage>): NotifyVirtualDaaScoreChangedResponseMessage {
    return NotifyVirtualDaaScoreChangedResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<NotifyVirtualDaaScoreChangedResponseMessage>
  ): NotifyVirtualDaaScoreChangedResponseMessage {
    const message = createBaseNotifyVirtualDaaScoreChangedResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseVirtualDaaScoreChangedNotificationMessage(): VirtualDaaScoreChangedNotificationMessage {
  return { virtualDaaScore: 0 };
}

export const VirtualDaaScoreChangedNotificationMessage: MessageFns<VirtualDaaScoreChangedNotificationMessage> = {
  encode(message: VirtualDaaScoreChangedNotificationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.virtualDaaScore !== 0) {
      writer.uint32(8).uint64(message.virtualDaaScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualDaaScoreChangedNotificationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualDaaScoreChangedNotificationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.virtualDaaScore = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<VirtualDaaScoreChangedNotificationMessage>): VirtualDaaScoreChangedNotificationMessage {
    return VirtualDaaScoreChangedNotificationMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VirtualDaaScoreChangedNotificationMessage>
  ): VirtualDaaScoreChangedNotificationMessage {
    const message = createBaseVirtualDaaScoreChangedNotificationMessage();
    message.virtualDaaScore = object.virtualDaaScore ?? 0;
    return message;
  }
};

function createBaseNotifyPruningPointUtxoSetOverrideRequestMessage(): NotifyPruningPointUtxoSetOverrideRequestMessage {
  return { command: 0 };
}

export const NotifyPruningPointUtxoSetOverrideRequestMessage: MessageFns<NotifyPruningPointUtxoSetOverrideRequestMessage> =
  {
    encode(
      message: NotifyPruningPointUtxoSetOverrideRequestMessage,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.command !== 0) {
        writer.uint32(808).int32(message.command);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): NotifyPruningPointUtxoSetOverrideRequestMessage {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseNotifyPruningPointUtxoSetOverrideRequestMessage();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 101: {
            if (tag !== 808) {
              break;
            }

            message.command = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<NotifyPruningPointUtxoSetOverrideRequestMessage>
    ): NotifyPruningPointUtxoSetOverrideRequestMessage {
      return NotifyPruningPointUtxoSetOverrideRequestMessage.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<NotifyPruningPointUtxoSetOverrideRequestMessage>
    ): NotifyPruningPointUtxoSetOverrideRequestMessage {
      const message = createBaseNotifyPruningPointUtxoSetOverrideRequestMessage();
      message.command = object.command ?? 0;
      return message;
    }
  };

function createBaseNotifyPruningPointUtxoSetOverrideResponseMessage(): NotifyPruningPointUtxoSetOverrideResponseMessage {
  return { error: undefined };
}

export const NotifyPruningPointUtxoSetOverrideResponseMessage: MessageFns<NotifyPruningPointUtxoSetOverrideResponseMessage> =
  {
    encode(
      message: NotifyPruningPointUtxoSetOverrideResponseMessage,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.error !== undefined) {
        RPCError.encode(message.error, writer.uint32(8002).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): NotifyPruningPointUtxoSetOverrideResponseMessage {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseNotifyPruningPointUtxoSetOverrideResponseMessage();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1000: {
            if (tag !== 8002) {
              break;
            }

            message.error = RPCError.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<NotifyPruningPointUtxoSetOverrideResponseMessage>
    ): NotifyPruningPointUtxoSetOverrideResponseMessage {
      return NotifyPruningPointUtxoSetOverrideResponseMessage.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<NotifyPruningPointUtxoSetOverrideResponseMessage>
    ): NotifyPruningPointUtxoSetOverrideResponseMessage {
      const message = createBaseNotifyPruningPointUtxoSetOverrideResponseMessage();
      message.error =
        object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
      return message;
    }
  };

function createBasePruningPointUtxoSetOverrideNotificationMessage(): PruningPointUtxoSetOverrideNotificationMessage {
  return {};
}

export const PruningPointUtxoSetOverrideNotificationMessage: MessageFns<PruningPointUtxoSetOverrideNotificationMessage> =
  {
    encode(_: PruningPointUtxoSetOverrideNotificationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): PruningPointUtxoSetOverrideNotificationMessage {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBasePruningPointUtxoSetOverrideNotificationMessage();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<PruningPointUtxoSetOverrideNotificationMessage>
    ): PruningPointUtxoSetOverrideNotificationMessage {
      return PruningPointUtxoSetOverrideNotificationMessage.fromPartial(base ?? {});
    },
    fromPartial(
      _: DeepPartial<PruningPointUtxoSetOverrideNotificationMessage>
    ): PruningPointUtxoSetOverrideNotificationMessage {
      const message = createBasePruningPointUtxoSetOverrideNotificationMessage();
      return message;
    }
  };

function createBaseStopNotifyingPruningPointUtxoSetOverrideRequestMessage(): StopNotifyingPruningPointUtxoSetOverrideRequestMessage {
  return {};
}

export const StopNotifyingPruningPointUtxoSetOverrideRequestMessage: MessageFns<StopNotifyingPruningPointUtxoSetOverrideRequestMessage> =
  {
    encode(
      _: StopNotifyingPruningPointUtxoSetOverrideRequestMessage,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): StopNotifyingPruningPointUtxoSetOverrideRequestMessage {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStopNotifyingPruningPointUtxoSetOverrideRequestMessage();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<StopNotifyingPruningPointUtxoSetOverrideRequestMessage>
    ): StopNotifyingPruningPointUtxoSetOverrideRequestMessage {
      return StopNotifyingPruningPointUtxoSetOverrideRequestMessage.fromPartial(base ?? {});
    },
    fromPartial(
      _: DeepPartial<StopNotifyingPruningPointUtxoSetOverrideRequestMessage>
    ): StopNotifyingPruningPointUtxoSetOverrideRequestMessage {
      const message = createBaseStopNotifyingPruningPointUtxoSetOverrideRequestMessage();
      return message;
    }
  };

function createBaseStopNotifyingPruningPointUtxoSetOverrideResponseMessage(): StopNotifyingPruningPointUtxoSetOverrideResponseMessage {
  return { error: undefined };
}

export const StopNotifyingPruningPointUtxoSetOverrideResponseMessage: MessageFns<StopNotifyingPruningPointUtxoSetOverrideResponseMessage> =
  {
    encode(
      message: StopNotifyingPruningPointUtxoSetOverrideResponseMessage,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.error !== undefined) {
        RPCError.encode(message.error, writer.uint32(8002).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): StopNotifyingPruningPointUtxoSetOverrideResponseMessage {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStopNotifyingPruningPointUtxoSetOverrideResponseMessage();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1000: {
            if (tag !== 8002) {
              break;
            }

            message.error = RPCError.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<StopNotifyingPruningPointUtxoSetOverrideResponseMessage>
    ): StopNotifyingPruningPointUtxoSetOverrideResponseMessage {
      return StopNotifyingPruningPointUtxoSetOverrideResponseMessage.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<StopNotifyingPruningPointUtxoSetOverrideResponseMessage>
    ): StopNotifyingPruningPointUtxoSetOverrideResponseMessage {
      const message = createBaseStopNotifyingPruningPointUtxoSetOverrideResponseMessage();
      message.error =
        object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
      return message;
    }
  };

function createBaseBanRequestMessage(): BanRequestMessage {
  return { ip: '' };
}

export const BanRequestMessage: MessageFns<BanRequestMessage> = {
  encode(message: BanRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip !== '') {
      writer.uint32(10).string(message.ip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BanRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBanRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ip = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BanRequestMessage>): BanRequestMessage {
    return BanRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BanRequestMessage>): BanRequestMessage {
    const message = createBaseBanRequestMessage();
    message.ip = object.ip ?? '';
    return message;
  }
};

function createBaseBanResponseMessage(): BanResponseMessage {
  return { error: undefined };
}

export const BanResponseMessage: MessageFns<BanResponseMessage> = {
  encode(message: BanResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BanResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBanResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BanResponseMessage>): BanResponseMessage {
    return BanResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BanResponseMessage>): BanResponseMessage {
    const message = createBaseBanResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseUnbanRequestMessage(): UnbanRequestMessage {
  return { ip: '' };
}

export const UnbanRequestMessage: MessageFns<UnbanRequestMessage> = {
  encode(message: UnbanRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip !== '') {
      writer.uint32(10).string(message.ip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnbanRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnbanRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ip = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UnbanRequestMessage>): UnbanRequestMessage {
    return UnbanRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnbanRequestMessage>): UnbanRequestMessage {
    const message = createBaseUnbanRequestMessage();
    message.ip = object.ip ?? '';
    return message;
  }
};

function createBaseUnbanResponseMessage(): UnbanResponseMessage {
  return { error: undefined };
}

export const UnbanResponseMessage: MessageFns<UnbanResponseMessage> = {
  encode(message: UnbanResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnbanResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnbanResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UnbanResponseMessage>): UnbanResponseMessage {
    return UnbanResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnbanResponseMessage>): UnbanResponseMessage {
    const message = createBaseUnbanResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetInfoRequestMessage(): GetInfoRequestMessage {
  return {};
}

export const GetInfoRequestMessage: MessageFns<GetInfoRequestMessage> = {
  encode(_: GetInfoRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInfoRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInfoRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetInfoRequestMessage>): GetInfoRequestMessage {
    return GetInfoRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetInfoRequestMessage>): GetInfoRequestMessage {
    const message = createBaseGetInfoRequestMessage();
    return message;
  }
};

function createBaseGetInfoResponseMessage(): GetInfoResponseMessage {
  return {
    p2pId: '',
    mempoolSize: 0,
    serverVersion: '',
    isUtxoIndexed: false,
    isSynced: false,
    hasNotifyCommand: false,
    hasMessageId: false,
    error: undefined
  };
}

export const GetInfoResponseMessage: MessageFns<GetInfoResponseMessage> = {
  encode(message: GetInfoResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.p2pId !== '') {
      writer.uint32(10).string(message.p2pId);
    }
    if (message.mempoolSize !== 0) {
      writer.uint32(16).uint64(message.mempoolSize);
    }
    if (message.serverVersion !== '') {
      writer.uint32(26).string(message.serverVersion);
    }
    if (message.isUtxoIndexed !== false) {
      writer.uint32(32).bool(message.isUtxoIndexed);
    }
    if (message.isSynced !== false) {
      writer.uint32(40).bool(message.isSynced);
    }
    if (message.hasNotifyCommand !== false) {
      writer.uint32(88).bool(message.hasNotifyCommand);
    }
    if (message.hasMessageId !== false) {
      writer.uint32(96).bool(message.hasMessageId);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInfoResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInfoResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.p2pId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mempoolSize = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serverVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isUtxoIndexed = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isSynced = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.hasNotifyCommand = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.hasMessageId = reader.bool();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetInfoResponseMessage>): GetInfoResponseMessage {
    return GetInfoResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInfoResponseMessage>): GetInfoResponseMessage {
    const message = createBaseGetInfoResponseMessage();
    message.p2pId = object.p2pId ?? '';
    message.mempoolSize = object.mempoolSize ?? 0;
    message.serverVersion = object.serverVersion ?? '';
    message.isUtxoIndexed = object.isUtxoIndexed ?? false;
    message.isSynced = object.isSynced ?? false;
    message.hasNotifyCommand = object.hasNotifyCommand ?? false;
    message.hasMessageId = object.hasMessageId ?? false;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseEstimateNetworkHashesPerSecondRequestMessage(): EstimateNetworkHashesPerSecondRequestMessage {
  return { windowSize: 0, startHash: '' };
}

export const EstimateNetworkHashesPerSecondRequestMessage: MessageFns<EstimateNetworkHashesPerSecondRequestMessage> = {
  encode(
    message: EstimateNetworkHashesPerSecondRequestMessage,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.windowSize !== 0) {
      writer.uint32(8).uint32(message.windowSize);
    }
    if (message.startHash !== '') {
      writer.uint32(18).string(message.startHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateNetworkHashesPerSecondRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateNetworkHashesPerSecondRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.windowSize = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<EstimateNetworkHashesPerSecondRequestMessage>
  ): EstimateNetworkHashesPerSecondRequestMessage {
    return EstimateNetworkHashesPerSecondRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<EstimateNetworkHashesPerSecondRequestMessage>
  ): EstimateNetworkHashesPerSecondRequestMessage {
    const message = createBaseEstimateNetworkHashesPerSecondRequestMessage();
    message.windowSize = object.windowSize ?? 0;
    message.startHash = object.startHash ?? '';
    return message;
  }
};

function createBaseEstimateNetworkHashesPerSecondResponseMessage(): EstimateNetworkHashesPerSecondResponseMessage {
  return { networkHashesPerSecond: 0, error: undefined };
}

export const EstimateNetworkHashesPerSecondResponseMessage: MessageFns<EstimateNetworkHashesPerSecondResponseMessage> =
  {
    encode(
      message: EstimateNetworkHashesPerSecondResponseMessage,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.networkHashesPerSecond !== 0) {
        writer.uint32(8).uint64(message.networkHashesPerSecond);
      }
      if (message.error !== undefined) {
        RPCError.encode(message.error, writer.uint32(8002).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EstimateNetworkHashesPerSecondResponseMessage {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEstimateNetworkHashesPerSecondResponseMessage();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.networkHashesPerSecond = longToNumber(reader.uint64());
            continue;
          }
          case 1000: {
            if (tag !== 8002) {
              break;
            }

            message.error = RPCError.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<EstimateNetworkHashesPerSecondResponseMessage>
    ): EstimateNetworkHashesPerSecondResponseMessage {
      return EstimateNetworkHashesPerSecondResponseMessage.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<EstimateNetworkHashesPerSecondResponseMessage>
    ): EstimateNetworkHashesPerSecondResponseMessage {
      const message = createBaseEstimateNetworkHashesPerSecondResponseMessage();
      message.networkHashesPerSecond = object.networkHashesPerSecond ?? 0;
      message.error =
        object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
      return message;
    }
  };

function createBaseNotifyNewBlockTemplateRequestMessage(): NotifyNewBlockTemplateRequestMessage {
  return { command: 0 };
}

export const NotifyNewBlockTemplateRequestMessage: MessageFns<NotifyNewBlockTemplateRequestMessage> = {
  encode(message: NotifyNewBlockTemplateRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== 0) {
      writer.uint32(808).int32(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyNewBlockTemplateRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyNewBlockTemplateRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 101: {
          if (tag !== 808) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyNewBlockTemplateRequestMessage>): NotifyNewBlockTemplateRequestMessage {
    return NotifyNewBlockTemplateRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyNewBlockTemplateRequestMessage>): NotifyNewBlockTemplateRequestMessage {
    const message = createBaseNotifyNewBlockTemplateRequestMessage();
    message.command = object.command ?? 0;
    return message;
  }
};

function createBaseNotifyNewBlockTemplateResponseMessage(): NotifyNewBlockTemplateResponseMessage {
  return { error: undefined };
}

export const NotifyNewBlockTemplateResponseMessage: MessageFns<NotifyNewBlockTemplateResponseMessage> = {
  encode(message: NotifyNewBlockTemplateResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyNewBlockTemplateResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyNewBlockTemplateResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NotifyNewBlockTemplateResponseMessage>): NotifyNewBlockTemplateResponseMessage {
    return NotifyNewBlockTemplateResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyNewBlockTemplateResponseMessage>): NotifyNewBlockTemplateResponseMessage {
    const message = createBaseNotifyNewBlockTemplateResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseNewBlockTemplateNotificationMessage(): NewBlockTemplateNotificationMessage {
  return {};
}

export const NewBlockTemplateNotificationMessage: MessageFns<NewBlockTemplateNotificationMessage> = {
  encode(_: NewBlockTemplateNotificationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewBlockTemplateNotificationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewBlockTemplateNotificationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NewBlockTemplateNotificationMessage>): NewBlockTemplateNotificationMessage {
    return NewBlockTemplateNotificationMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<NewBlockTemplateNotificationMessage>): NewBlockTemplateNotificationMessage {
    const message = createBaseNewBlockTemplateNotificationMessage();
    return message;
  }
};

function createBaseRpcMempoolEntryByAddress(): RpcMempoolEntryByAddress {
  return { address: '', sending: [], receiving: [] };
}

export const RpcMempoolEntryByAddress: MessageFns<RpcMempoolEntryByAddress> = {
  encode(message: RpcMempoolEntryByAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== '') {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.sending) {
      RpcMempoolEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.receiving) {
      RpcMempoolEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcMempoolEntryByAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcMempoolEntryByAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sending.push(RpcMempoolEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiving.push(RpcMempoolEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcMempoolEntryByAddress>): RpcMempoolEntryByAddress {
    return RpcMempoolEntryByAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcMempoolEntryByAddress>): RpcMempoolEntryByAddress {
    const message = createBaseRpcMempoolEntryByAddress();
    message.address = object.address ?? '';
    message.sending = object.sending?.map((e) => RpcMempoolEntry.fromPartial(e)) || [];
    message.receiving = object.receiving?.map((e) => RpcMempoolEntry.fromPartial(e)) || [];
    return message;
  }
};

function createBaseGetMempoolEntriesByAddressesRequestMessage(): GetMempoolEntriesByAddressesRequestMessage {
  return { addresses: [], includeOrphanPool: false, filterTransactionPool: false };
}

export const GetMempoolEntriesByAddressesRequestMessage: MessageFns<GetMempoolEntriesByAddressesRequestMessage> = {
  encode(message: GetMempoolEntriesByAddressesRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      writer.uint32(10).string(v!);
    }
    if (message.includeOrphanPool !== false) {
      writer.uint32(16).bool(message.includeOrphanPool);
    }
    if (message.filterTransactionPool !== false) {
      writer.uint32(24).bool(message.filterTransactionPool);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolEntriesByAddressesRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolEntriesByAddressesRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeOrphanPool = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.filterTransactionPool = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMempoolEntriesByAddressesRequestMessage>): GetMempoolEntriesByAddressesRequestMessage {
    return GetMempoolEntriesByAddressesRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetMempoolEntriesByAddressesRequestMessage>
  ): GetMempoolEntriesByAddressesRequestMessage {
    const message = createBaseGetMempoolEntriesByAddressesRequestMessage();
    message.addresses = object.addresses?.map((e) => e) || [];
    message.includeOrphanPool = object.includeOrphanPool ?? false;
    message.filterTransactionPool = object.filterTransactionPool ?? false;
    return message;
  }
};

function createBaseGetMempoolEntriesByAddressesResponseMessage(): GetMempoolEntriesByAddressesResponseMessage {
  return { entries: [], error: undefined };
}

export const GetMempoolEntriesByAddressesResponseMessage: MessageFns<GetMempoolEntriesByAddressesResponseMessage> = {
  encode(
    message: GetMempoolEntriesByAddressesResponseMessage,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.entries) {
      RpcMempoolEntryByAddress.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolEntriesByAddressesResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolEntriesByAddressesResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(RpcMempoolEntryByAddress.decode(reader, reader.uint32()));
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMempoolEntriesByAddressesResponseMessage>): GetMempoolEntriesByAddressesResponseMessage {
    return GetMempoolEntriesByAddressesResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetMempoolEntriesByAddressesResponseMessage>
  ): GetMempoolEntriesByAddressesResponseMessage {
    const message = createBaseGetMempoolEntriesByAddressesResponseMessage();
    message.entries = object.entries?.map((e) => RpcMempoolEntryByAddress.fromPartial(e)) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetCoinSupplyRequestMessage(): GetCoinSupplyRequestMessage {
  return {};
}

export const GetCoinSupplyRequestMessage: MessageFns<GetCoinSupplyRequestMessage> = {
  encode(_: GetCoinSupplyRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCoinSupplyRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCoinSupplyRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetCoinSupplyRequestMessage>): GetCoinSupplyRequestMessage {
    return GetCoinSupplyRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetCoinSupplyRequestMessage>): GetCoinSupplyRequestMessage {
    const message = createBaseGetCoinSupplyRequestMessage();
    return message;
  }
};

function createBaseGetCoinSupplyResponseMessage(): GetCoinSupplyResponseMessage {
  return { maxSompi: 0, circulatingSompi: 0, error: undefined };
}

export const GetCoinSupplyResponseMessage: MessageFns<GetCoinSupplyResponseMessage> = {
  encode(message: GetCoinSupplyResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxSompi !== 0) {
      writer.uint32(8).uint64(message.maxSompi);
    }
    if (message.circulatingSompi !== 0) {
      writer.uint32(16).uint64(message.circulatingSompi);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCoinSupplyResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCoinSupplyResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxSompi = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.circulatingSompi = longToNumber(reader.uint64());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetCoinSupplyResponseMessage>): GetCoinSupplyResponseMessage {
    return GetCoinSupplyResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCoinSupplyResponseMessage>): GetCoinSupplyResponseMessage {
    const message = createBaseGetCoinSupplyResponseMessage();
    message.maxSompi = object.maxSompi ?? 0;
    message.circulatingSompi = object.circulatingSompi ?? 0;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBasePingRequestMessage(): PingRequestMessage {
  return {};
}

export const PingRequestMessage: MessageFns<PingRequestMessage> = {
  encode(_: PingRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PingRequestMessage>): PingRequestMessage {
    return PingRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingRequestMessage>): PingRequestMessage {
    const message = createBasePingRequestMessage();
    return message;
  }
};

function createBasePingResponseMessage(): PingResponseMessage {
  return { error: undefined };
}

export const PingResponseMessage: MessageFns<PingResponseMessage> = {
  encode(message: PingResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PingResponseMessage>): PingResponseMessage {
    return PingResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PingResponseMessage>): PingResponseMessage {
    const message = createBasePingResponseMessage();
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseProcessMetrics(): ProcessMetrics {
  return {
    residentSetSize: 0,
    virtualMemorySize: 0,
    coreNum: 0,
    cpuUsage: 0,
    fdNum: 0,
    diskIoReadBytes: 0,
    diskIoWriteBytes: 0,
    diskIoReadPerSec: 0,
    diskIoWritePerSec: 0
  };
}

export const ProcessMetrics: MessageFns<ProcessMetrics> = {
  encode(message: ProcessMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.residentSetSize !== 0) {
      writer.uint32(8).uint64(message.residentSetSize);
    }
    if (message.virtualMemorySize !== 0) {
      writer.uint32(16).uint64(message.virtualMemorySize);
    }
    if (message.coreNum !== 0) {
      writer.uint32(24).uint32(message.coreNum);
    }
    if (message.cpuUsage !== 0) {
      writer.uint32(37).float(message.cpuUsage);
    }
    if (message.fdNum !== 0) {
      writer.uint32(40).uint32(message.fdNum);
    }
    if (message.diskIoReadBytes !== 0) {
      writer.uint32(48).uint64(message.diskIoReadBytes);
    }
    if (message.diskIoWriteBytes !== 0) {
      writer.uint32(56).uint64(message.diskIoWriteBytes);
    }
    if (message.diskIoReadPerSec !== 0) {
      writer.uint32(69).float(message.diskIoReadPerSec);
    }
    if (message.diskIoWritePerSec !== 0) {
      writer.uint32(77).float(message.diskIoWritePerSec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.residentSetSize = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.virtualMemorySize = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.coreNum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.cpuUsage = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fdNum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.diskIoReadBytes = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.diskIoWriteBytes = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.diskIoReadPerSec = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.diskIoWritePerSec = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ProcessMetrics>): ProcessMetrics {
    return ProcessMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessMetrics>): ProcessMetrics {
    const message = createBaseProcessMetrics();
    message.residentSetSize = object.residentSetSize ?? 0;
    message.virtualMemorySize = object.virtualMemorySize ?? 0;
    message.coreNum = object.coreNum ?? 0;
    message.cpuUsage = object.cpuUsage ?? 0;
    message.fdNum = object.fdNum ?? 0;
    message.diskIoReadBytes = object.diskIoReadBytes ?? 0;
    message.diskIoWriteBytes = object.diskIoWriteBytes ?? 0;
    message.diskIoReadPerSec = object.diskIoReadPerSec ?? 0;
    message.diskIoWritePerSec = object.diskIoWritePerSec ?? 0;
    return message;
  }
};

function createBaseConnectionMetrics(): ConnectionMetrics {
  return {
    borshLiveConnections: 0,
    borshConnectionAttempts: 0,
    borshHandshakeFailures: 0,
    jsonLiveConnections: 0,
    jsonConnectionAttempts: 0,
    jsonHandshakeFailures: 0,
    activePeers: 0
  };
}

export const ConnectionMetrics: MessageFns<ConnectionMetrics> = {
  encode(message: ConnectionMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.borshLiveConnections !== 0) {
      writer.uint32(248).uint32(message.borshLiveConnections);
    }
    if (message.borshConnectionAttempts !== 0) {
      writer.uint32(256).uint64(message.borshConnectionAttempts);
    }
    if (message.borshHandshakeFailures !== 0) {
      writer.uint32(264).uint64(message.borshHandshakeFailures);
    }
    if (message.jsonLiveConnections !== 0) {
      writer.uint32(328).uint32(message.jsonLiveConnections);
    }
    if (message.jsonConnectionAttempts !== 0) {
      writer.uint32(336).uint64(message.jsonConnectionAttempts);
    }
    if (message.jsonHandshakeFailures !== 0) {
      writer.uint32(344).uint64(message.jsonHandshakeFailures);
    }
    if (message.activePeers !== 0) {
      writer.uint32(408).uint32(message.activePeers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.borshLiveConnections = reader.uint32();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.borshConnectionAttempts = longToNumber(reader.uint64());
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.borshHandshakeFailures = longToNumber(reader.uint64());
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.jsonLiveConnections = reader.uint32();
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }

          message.jsonConnectionAttempts = longToNumber(reader.uint64());
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }

          message.jsonHandshakeFailures = longToNumber(reader.uint64());
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.activePeers = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ConnectionMetrics>): ConnectionMetrics {
    return ConnectionMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionMetrics>): ConnectionMetrics {
    const message = createBaseConnectionMetrics();
    message.borshLiveConnections = object.borshLiveConnections ?? 0;
    message.borshConnectionAttempts = object.borshConnectionAttempts ?? 0;
    message.borshHandshakeFailures = object.borshHandshakeFailures ?? 0;
    message.jsonLiveConnections = object.jsonLiveConnections ?? 0;
    message.jsonConnectionAttempts = object.jsonConnectionAttempts ?? 0;
    message.jsonHandshakeFailures = object.jsonHandshakeFailures ?? 0;
    message.activePeers = object.activePeers ?? 0;
    return message;
  }
};

function createBaseBandwidthMetrics(): BandwidthMetrics {
  return {
    borshBytesTx: 0,
    borshBytesRx: 0,
    jsonBytesTx: 0,
    jsonBytesRx: 0,
    grpcP2pBytesTx: 0,
    grpcP2pBytesRx: 0,
    grpcUserBytesTx: 0,
    grpcUserBytesRx: 0
  };
}

export const BandwidthMetrics: MessageFns<BandwidthMetrics> = {
  encode(message: BandwidthMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.borshBytesTx !== 0) {
      writer.uint32(488).uint64(message.borshBytesTx);
    }
    if (message.borshBytesRx !== 0) {
      writer.uint32(496).uint64(message.borshBytesRx);
    }
    if (message.jsonBytesTx !== 0) {
      writer.uint32(504).uint64(message.jsonBytesTx);
    }
    if (message.jsonBytesRx !== 0) {
      writer.uint32(512).uint64(message.jsonBytesRx);
    }
    if (message.grpcP2pBytesTx !== 0) {
      writer.uint32(520).uint64(message.grpcP2pBytesTx);
    }
    if (message.grpcP2pBytesRx !== 0) {
      writer.uint32(528).uint64(message.grpcP2pBytesRx);
    }
    if (message.grpcUserBytesTx !== 0) {
      writer.uint32(536).uint64(message.grpcUserBytesTx);
    }
    if (message.grpcUserBytesRx !== 0) {
      writer.uint32(544).uint64(message.grpcUserBytesRx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BandwidthMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBandwidthMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 61: {
          if (tag !== 488) {
            break;
          }

          message.borshBytesTx = longToNumber(reader.uint64());
          continue;
        }
        case 62: {
          if (tag !== 496) {
            break;
          }

          message.borshBytesRx = longToNumber(reader.uint64());
          continue;
        }
        case 63: {
          if (tag !== 504) {
            break;
          }

          message.jsonBytesTx = longToNumber(reader.uint64());
          continue;
        }
        case 64: {
          if (tag !== 512) {
            break;
          }

          message.jsonBytesRx = longToNumber(reader.uint64());
          continue;
        }
        case 65: {
          if (tag !== 520) {
            break;
          }

          message.grpcP2pBytesTx = longToNumber(reader.uint64());
          continue;
        }
        case 66: {
          if (tag !== 528) {
            break;
          }

          message.grpcP2pBytesRx = longToNumber(reader.uint64());
          continue;
        }
        case 67: {
          if (tag !== 536) {
            break;
          }

          message.grpcUserBytesTx = longToNumber(reader.uint64());
          continue;
        }
        case 68: {
          if (tag !== 544) {
            break;
          }

          message.grpcUserBytesRx = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BandwidthMetrics>): BandwidthMetrics {
    return BandwidthMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BandwidthMetrics>): BandwidthMetrics {
    const message = createBaseBandwidthMetrics();
    message.borshBytesTx = object.borshBytesTx ?? 0;
    message.borshBytesRx = object.borshBytesRx ?? 0;
    message.jsonBytesTx = object.jsonBytesTx ?? 0;
    message.jsonBytesRx = object.jsonBytesRx ?? 0;
    message.grpcP2pBytesTx = object.grpcP2pBytesTx ?? 0;
    message.grpcP2pBytesRx = object.grpcP2pBytesRx ?? 0;
    message.grpcUserBytesTx = object.grpcUserBytesTx ?? 0;
    message.grpcUserBytesRx = object.grpcUserBytesRx ?? 0;
    return message;
  }
};

function createBaseConsensusMetrics(): ConsensusMetrics {
  return {
    blocksSubmitted: 0,
    headerCounts: 0,
    depCounts: 0,
    bodyCounts: 0,
    txsCounts: 0,
    chainBlockCounts: 0,
    massCounts: 0,
    blockCount: 0,
    headerCount: 0,
    mempoolSize: 0,
    tipHashesCount: 0,
    difficulty: 0,
    pastMedianTime: 0,
    virtualParentHashesCount: 0,
    virtualDaaScore: 0
  };
}

export const ConsensusMetrics: MessageFns<ConsensusMetrics> = {
  encode(message: ConsensusMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blocksSubmitted !== 0) {
      writer.uint32(8).uint64(message.blocksSubmitted);
    }
    if (message.headerCounts !== 0) {
      writer.uint32(16).uint64(message.headerCounts);
    }
    if (message.depCounts !== 0) {
      writer.uint32(24).uint64(message.depCounts);
    }
    if (message.bodyCounts !== 0) {
      writer.uint32(32).uint64(message.bodyCounts);
    }
    if (message.txsCounts !== 0) {
      writer.uint32(40).uint64(message.txsCounts);
    }
    if (message.chainBlockCounts !== 0) {
      writer.uint32(48).uint64(message.chainBlockCounts);
    }
    if (message.massCounts !== 0) {
      writer.uint32(56).uint64(message.massCounts);
    }
    if (message.blockCount !== 0) {
      writer.uint32(88).uint64(message.blockCount);
    }
    if (message.headerCount !== 0) {
      writer.uint32(96).uint64(message.headerCount);
    }
    if (message.mempoolSize !== 0) {
      writer.uint32(104).uint64(message.mempoolSize);
    }
    if (message.tipHashesCount !== 0) {
      writer.uint32(112).uint32(message.tipHashesCount);
    }
    if (message.difficulty !== 0) {
      writer.uint32(121).double(message.difficulty);
    }
    if (message.pastMedianTime !== 0) {
      writer.uint32(128).uint64(message.pastMedianTime);
    }
    if (message.virtualParentHashesCount !== 0) {
      writer.uint32(136).uint32(message.virtualParentHashesCount);
    }
    if (message.virtualDaaScore !== 0) {
      writer.uint32(144).uint64(message.virtualDaaScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsensusMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsensusMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blocksSubmitted = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.headerCounts = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.depCounts = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bodyCounts = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.txsCounts = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.chainBlockCounts = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.massCounts = longToNumber(reader.uint64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.blockCount = longToNumber(reader.uint64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.headerCount = longToNumber(reader.uint64());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.mempoolSize = longToNumber(reader.uint64());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.tipHashesCount = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 121) {
            break;
          }

          message.difficulty = reader.double();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.pastMedianTime = longToNumber(reader.uint64());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.virtualParentHashesCount = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.virtualDaaScore = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ConsensusMetrics>): ConsensusMetrics {
    return ConsensusMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConsensusMetrics>): ConsensusMetrics {
    const message = createBaseConsensusMetrics();
    message.blocksSubmitted = object.blocksSubmitted ?? 0;
    message.headerCounts = object.headerCounts ?? 0;
    message.depCounts = object.depCounts ?? 0;
    message.bodyCounts = object.bodyCounts ?? 0;
    message.txsCounts = object.txsCounts ?? 0;
    message.chainBlockCounts = object.chainBlockCounts ?? 0;
    message.massCounts = object.massCounts ?? 0;
    message.blockCount = object.blockCount ?? 0;
    message.headerCount = object.headerCount ?? 0;
    message.mempoolSize = object.mempoolSize ?? 0;
    message.tipHashesCount = object.tipHashesCount ?? 0;
    message.difficulty = object.difficulty ?? 0;
    message.pastMedianTime = object.pastMedianTime ?? 0;
    message.virtualParentHashesCount = object.virtualParentHashesCount ?? 0;
    message.virtualDaaScore = object.virtualDaaScore ?? 0;
    return message;
  }
};

function createBaseStorageMetrics(): StorageMetrics {
  return { storageSizeBytes: 0 };
}

export const StorageMetrics: MessageFns<StorageMetrics> = {
  encode(message: StorageMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.storageSizeBytes !== 0) {
      writer.uint32(8).uint64(message.storageSizeBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.storageSizeBytes = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StorageMetrics>): StorageMetrics {
    return StorageMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorageMetrics>): StorageMetrics {
    const message = createBaseStorageMetrics();
    message.storageSizeBytes = object.storageSizeBytes ?? 0;
    return message;
  }
};

function createBaseGetConnectionsRequestMessage(): GetConnectionsRequestMessage {
  return { includeProfileData: false };
}

export const GetConnectionsRequestMessage: MessageFns<GetConnectionsRequestMessage> = {
  encode(message: GetConnectionsRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeProfileData !== false) {
      writer.uint32(8).bool(message.includeProfileData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionsRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionsRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.includeProfileData = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetConnectionsRequestMessage>): GetConnectionsRequestMessage {
    return GetConnectionsRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionsRequestMessage>): GetConnectionsRequestMessage {
    const message = createBaseGetConnectionsRequestMessage();
    message.includeProfileData = object.includeProfileData ?? false;
    return message;
  }
};

function createBaseConnectionsProfileData(): ConnectionsProfileData {
  return { cpuUsage: 0, memoryUsage: 0 };
}

export const ConnectionsProfileData: MessageFns<ConnectionsProfileData> = {
  encode(message: ConnectionsProfileData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuUsage !== 0) {
      writer.uint32(9).double(message.cpuUsage);
    }
    if (message.memoryUsage !== 0) {
      writer.uint32(16).uint64(message.memoryUsage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionsProfileData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionsProfileData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.cpuUsage = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memoryUsage = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ConnectionsProfileData>): ConnectionsProfileData {
    return ConnectionsProfileData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionsProfileData>): ConnectionsProfileData {
    const message = createBaseConnectionsProfileData();
    message.cpuUsage = object.cpuUsage ?? 0;
    message.memoryUsage = object.memoryUsage ?? 0;
    return message;
  }
};

function createBaseGetConnectionsResponseMessage(): GetConnectionsResponseMessage {
  return { clients: 0, peers: 0, profileData: undefined, error: undefined };
}

export const GetConnectionsResponseMessage: MessageFns<GetConnectionsResponseMessage> = {
  encode(message: GetConnectionsResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clients !== 0) {
      writer.uint32(8).uint32(message.clients);
    }
    if (message.peers !== 0) {
      writer.uint32(16).uint32(message.peers);
    }
    if (message.profileData !== undefined) {
      ConnectionsProfileData.encode(message.profileData, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionsResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionsResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.clients = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.peers = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.profileData = ConnectionsProfileData.decode(reader, reader.uint32());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetConnectionsResponseMessage>): GetConnectionsResponseMessage {
    return GetConnectionsResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionsResponseMessage>): GetConnectionsResponseMessage {
    const message = createBaseGetConnectionsResponseMessage();
    message.clients = object.clients ?? 0;
    message.peers = object.peers ?? 0;
    message.profileData =
      object.profileData !== undefined && object.profileData !== null
        ? ConnectionsProfileData.fromPartial(object.profileData)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetSystemInfoRequestMessage(): GetSystemInfoRequestMessage {
  return {};
}

export const GetSystemInfoRequestMessage: MessageFns<GetSystemInfoRequestMessage> = {
  encode(_: GetSystemInfoRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSystemInfoRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSystemInfoRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSystemInfoRequestMessage>): GetSystemInfoRequestMessage {
    return GetSystemInfoRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetSystemInfoRequestMessage>): GetSystemInfoRequestMessage {
    const message = createBaseGetSystemInfoRequestMessage();
    return message;
  }
};

function createBaseGetSystemInfoResponseMessage(): GetSystemInfoResponseMessage {
  return {
    version: '',
    systemId: '',
    gitHash: '',
    coreNum: 0,
    totalMemory: 0,
    fdLimit: 0,
    proxySocketLimitPerCpuCore: 0,
    error: undefined
  };
}

export const GetSystemInfoResponseMessage: MessageFns<GetSystemInfoResponseMessage> = {
  encode(message: GetSystemInfoResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== '') {
      writer.uint32(10).string(message.version);
    }
    if (message.systemId !== '') {
      writer.uint32(18).string(message.systemId);
    }
    if (message.gitHash !== '') {
      writer.uint32(26).string(message.gitHash);
    }
    if (message.coreNum !== 0) {
      writer.uint32(32).uint32(message.coreNum);
    }
    if (message.totalMemory !== 0) {
      writer.uint32(40).uint64(message.totalMemory);
    }
    if (message.fdLimit !== 0) {
      writer.uint32(48).uint32(message.fdLimit);
    }
    if (message.proxySocketLimitPerCpuCore !== 0) {
      writer.uint32(56).uint32(message.proxySocketLimitPerCpuCore);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSystemInfoResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSystemInfoResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.systemId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gitHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.coreNum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalMemory = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fdLimit = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.proxySocketLimitPerCpuCore = reader.uint32();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSystemInfoResponseMessage>): GetSystemInfoResponseMessage {
    return GetSystemInfoResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSystemInfoResponseMessage>): GetSystemInfoResponseMessage {
    const message = createBaseGetSystemInfoResponseMessage();
    message.version = object.version ?? '';
    message.systemId = object.systemId ?? '';
    message.gitHash = object.gitHash ?? '';
    message.coreNum = object.coreNum ?? 0;
    message.totalMemory = object.totalMemory ?? 0;
    message.fdLimit = object.fdLimit ?? 0;
    message.proxySocketLimitPerCpuCore = object.proxySocketLimitPerCpuCore ?? 0;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetMetricsRequestMessage(): GetMetricsRequestMessage {
  return {
    processMetrics: false,
    connectionMetrics: false,
    bandwidthMetrics: false,
    consensusMetrics: false,
    storageMetrics: false,
    customMetrics: false
  };
}

export const GetMetricsRequestMessage: MessageFns<GetMetricsRequestMessage> = {
  encode(message: GetMetricsRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processMetrics !== false) {
      writer.uint32(8).bool(message.processMetrics);
    }
    if (message.connectionMetrics !== false) {
      writer.uint32(16).bool(message.connectionMetrics);
    }
    if (message.bandwidthMetrics !== false) {
      writer.uint32(24).bool(message.bandwidthMetrics);
    }
    if (message.consensusMetrics !== false) {
      writer.uint32(32).bool(message.consensusMetrics);
    }
    if (message.storageMetrics !== false) {
      writer.uint32(40).bool(message.storageMetrics);
    }
    if (message.customMetrics !== false) {
      writer.uint32(48).bool(message.customMetrics);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMetricsRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processMetrics = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.connectionMetrics = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bandwidthMetrics = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.consensusMetrics = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storageMetrics = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.customMetrics = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMetricsRequestMessage>): GetMetricsRequestMessage {
    return GetMetricsRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMetricsRequestMessage>): GetMetricsRequestMessage {
    const message = createBaseGetMetricsRequestMessage();
    message.processMetrics = object.processMetrics ?? false;
    message.connectionMetrics = object.connectionMetrics ?? false;
    message.bandwidthMetrics = object.bandwidthMetrics ?? false;
    message.consensusMetrics = object.consensusMetrics ?? false;
    message.storageMetrics = object.storageMetrics ?? false;
    message.customMetrics = object.customMetrics ?? false;
    return message;
  }
};

function createBaseGetMetricsResponseMessage(): GetMetricsResponseMessage {
  return {
    serverTime: 0,
    processMetrics: undefined,
    connectionMetrics: undefined,
    bandwidthMetrics: undefined,
    consensusMetrics: undefined,
    storageMetrics: undefined,
    error: undefined
  };
}

export const GetMetricsResponseMessage: MessageFns<GetMetricsResponseMessage> = {
  encode(message: GetMetricsResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverTime !== 0) {
      writer.uint32(8).uint64(message.serverTime);
    }
    if (message.processMetrics !== undefined) {
      ProcessMetrics.encode(message.processMetrics, writer.uint32(90).fork()).join();
    }
    if (message.connectionMetrics !== undefined) {
      ConnectionMetrics.encode(message.connectionMetrics, writer.uint32(98).fork()).join();
    }
    if (message.bandwidthMetrics !== undefined) {
      BandwidthMetrics.encode(message.bandwidthMetrics, writer.uint32(106).fork()).join();
    }
    if (message.consensusMetrics !== undefined) {
      ConsensusMetrics.encode(message.consensusMetrics, writer.uint32(114).fork()).join();
    }
    if (message.storageMetrics !== undefined) {
      StorageMetrics.encode(message.storageMetrics, writer.uint32(122).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMetricsResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.serverTime = longToNumber(reader.uint64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.processMetrics = ProcessMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.connectionMetrics = ConnectionMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bandwidthMetrics = BandwidthMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.consensusMetrics = ConsensusMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.storageMetrics = StorageMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMetricsResponseMessage>): GetMetricsResponseMessage {
    return GetMetricsResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMetricsResponseMessage>): GetMetricsResponseMessage {
    const message = createBaseGetMetricsResponseMessage();
    message.serverTime = object.serverTime ?? 0;
    message.processMetrics =
      object.processMetrics !== undefined && object.processMetrics !== null
        ? ProcessMetrics.fromPartial(object.processMetrics)
        : undefined;
    message.connectionMetrics =
      object.connectionMetrics !== undefined && object.connectionMetrics !== null
        ? ConnectionMetrics.fromPartial(object.connectionMetrics)
        : undefined;
    message.bandwidthMetrics =
      object.bandwidthMetrics !== undefined && object.bandwidthMetrics !== null
        ? BandwidthMetrics.fromPartial(object.bandwidthMetrics)
        : undefined;
    message.consensusMetrics =
      object.consensusMetrics !== undefined && object.consensusMetrics !== null
        ? ConsensusMetrics.fromPartial(object.consensusMetrics)
        : undefined;
    message.storageMetrics =
      object.storageMetrics !== undefined && object.storageMetrics !== null
        ? StorageMetrics.fromPartial(object.storageMetrics)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetServerInfoRequestMessage(): GetServerInfoRequestMessage {
  return {};
}

export const GetServerInfoRequestMessage: MessageFns<GetServerInfoRequestMessage> = {
  encode(_: GetServerInfoRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServerInfoRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServerInfoRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetServerInfoRequestMessage>): GetServerInfoRequestMessage {
    return GetServerInfoRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetServerInfoRequestMessage>): GetServerInfoRequestMessage {
    const message = createBaseGetServerInfoRequestMessage();
    return message;
  }
};

function createBaseGetServerInfoResponseMessage(): GetServerInfoResponseMessage {
  return {
    rpcApiVersion: 0,
    rpcApiRevision: 0,
    serverVersion: '',
    networkId: '',
    hasUtxoIndex: false,
    isSynced: false,
    virtualDaaScore: 0,
    error: undefined
  };
}

export const GetServerInfoResponseMessage: MessageFns<GetServerInfoResponseMessage> = {
  encode(message: GetServerInfoResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rpcApiVersion !== 0) {
      writer.uint32(8).uint32(message.rpcApiVersion);
    }
    if (message.rpcApiRevision !== 0) {
      writer.uint32(16).uint32(message.rpcApiRevision);
    }
    if (message.serverVersion !== '') {
      writer.uint32(26).string(message.serverVersion);
    }
    if (message.networkId !== '') {
      writer.uint32(34).string(message.networkId);
    }
    if (message.hasUtxoIndex !== false) {
      writer.uint32(40).bool(message.hasUtxoIndex);
    }
    if (message.isSynced !== false) {
      writer.uint32(48).bool(message.isSynced);
    }
    if (message.virtualDaaScore !== 0) {
      writer.uint32(56).uint64(message.virtualDaaScore);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServerInfoResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServerInfoResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rpcApiVersion = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rpcApiRevision = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serverVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.networkId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hasUtxoIndex = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isSynced = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.virtualDaaScore = longToNumber(reader.uint64());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetServerInfoResponseMessage>): GetServerInfoResponseMessage {
    return GetServerInfoResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetServerInfoResponseMessage>): GetServerInfoResponseMessage {
    const message = createBaseGetServerInfoResponseMessage();
    message.rpcApiVersion = object.rpcApiVersion ?? 0;
    message.rpcApiRevision = object.rpcApiRevision ?? 0;
    message.serverVersion = object.serverVersion ?? '';
    message.networkId = object.networkId ?? '';
    message.hasUtxoIndex = object.hasUtxoIndex ?? false;
    message.isSynced = object.isSynced ?? false;
    message.virtualDaaScore = object.virtualDaaScore ?? 0;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetSyncStatusRequestMessage(): GetSyncStatusRequestMessage {
  return {};
}

export const GetSyncStatusRequestMessage: MessageFns<GetSyncStatusRequestMessage> = {
  encode(_: GetSyncStatusRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSyncStatusRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSyncStatusRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSyncStatusRequestMessage>): GetSyncStatusRequestMessage {
    return GetSyncStatusRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetSyncStatusRequestMessage>): GetSyncStatusRequestMessage {
    const message = createBaseGetSyncStatusRequestMessage();
    return message;
  }
};

function createBaseGetSyncStatusResponseMessage(): GetSyncStatusResponseMessage {
  return { isSynced: false, error: undefined };
}

export const GetSyncStatusResponseMessage: MessageFns<GetSyncStatusResponseMessage> = {
  encode(message: GetSyncStatusResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSynced !== false) {
      writer.uint32(8).bool(message.isSynced);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSyncStatusResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSyncStatusResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSynced = reader.bool();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetSyncStatusResponseMessage>): GetSyncStatusResponseMessage {
    return GetSyncStatusResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSyncStatusResponseMessage>): GetSyncStatusResponseMessage {
    const message = createBaseGetSyncStatusResponseMessage();
    message.isSynced = object.isSynced ?? false;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetDaaScoreTimestampEstimateRequestMessage(): GetDaaScoreTimestampEstimateRequestMessage {
  return { daaScores: [] };
}

export const GetDaaScoreTimestampEstimateRequestMessage: MessageFns<GetDaaScoreTimestampEstimateRequestMessage> = {
  encode(message: GetDaaScoreTimestampEstimateRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.daaScores) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDaaScoreTimestampEstimateRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDaaScoreTimestampEstimateRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.daaScores.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.daaScores.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetDaaScoreTimestampEstimateRequestMessage>): GetDaaScoreTimestampEstimateRequestMessage {
    return GetDaaScoreTimestampEstimateRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetDaaScoreTimestampEstimateRequestMessage>
  ): GetDaaScoreTimestampEstimateRequestMessage {
    const message = createBaseGetDaaScoreTimestampEstimateRequestMessage();
    message.daaScores = object.daaScores?.map((e) => e) || [];
    return message;
  }
};

function createBaseGetDaaScoreTimestampEstimateResponseMessage(): GetDaaScoreTimestampEstimateResponseMessage {
  return { timestamps: [], error: undefined };
}

export const GetDaaScoreTimestampEstimateResponseMessage: MessageFns<GetDaaScoreTimestampEstimateResponseMessage> = {
  encode(
    message: GetDaaScoreTimestampEstimateResponseMessage,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.timestamps) {
      writer.uint64(v);
    }
    writer.join();
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDaaScoreTimestampEstimateResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDaaScoreTimestampEstimateResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.timestamps.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.timestamps.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetDaaScoreTimestampEstimateResponseMessage>): GetDaaScoreTimestampEstimateResponseMessage {
    return GetDaaScoreTimestampEstimateResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetDaaScoreTimestampEstimateResponseMessage>
  ): GetDaaScoreTimestampEstimateResponseMessage {
    const message = createBaseGetDaaScoreTimestampEstimateResponseMessage();
    message.timestamps = object.timestamps?.map((e) => e) || [];
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseRpcFeerateBucket(): RpcFeerateBucket {
  return { feerate: 0, estimatedSeconds: 0 };
}

export const RpcFeerateBucket: MessageFns<RpcFeerateBucket> = {
  encode(message: RpcFeerateBucket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feerate !== 0) {
      writer.uint32(9).double(message.feerate);
    }
    if (message.estimatedSeconds !== 0) {
      writer.uint32(17).double(message.estimatedSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcFeerateBucket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcFeerateBucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.feerate = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.estimatedSeconds = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcFeerateBucket>): RpcFeerateBucket {
    return RpcFeerateBucket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcFeerateBucket>): RpcFeerateBucket {
    const message = createBaseRpcFeerateBucket();
    message.feerate = object.feerate ?? 0;
    message.estimatedSeconds = object.estimatedSeconds ?? 0;
    return message;
  }
};

function createBaseRpcFeeEstimate(): RpcFeeEstimate {
  return { priorityBucket: undefined, normalBuckets: [], lowBuckets: [] };
}

export const RpcFeeEstimate: MessageFns<RpcFeeEstimate> = {
  encode(message: RpcFeeEstimate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.priorityBucket !== undefined) {
      RpcFeerateBucket.encode(message.priorityBucket, writer.uint32(10).fork()).join();
    }
    for (const v of message.normalBuckets) {
      RpcFeerateBucket.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.lowBuckets) {
      RpcFeerateBucket.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcFeeEstimate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcFeeEstimate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.priorityBucket = RpcFeerateBucket.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.normalBuckets.push(RpcFeerateBucket.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lowBuckets.push(RpcFeerateBucket.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcFeeEstimate>): RpcFeeEstimate {
    return RpcFeeEstimate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcFeeEstimate>): RpcFeeEstimate {
    const message = createBaseRpcFeeEstimate();
    message.priorityBucket =
      object.priorityBucket !== undefined && object.priorityBucket !== null
        ? RpcFeerateBucket.fromPartial(object.priorityBucket)
        : undefined;
    message.normalBuckets = object.normalBuckets?.map((e) => RpcFeerateBucket.fromPartial(e)) || [];
    message.lowBuckets = object.lowBuckets?.map((e) => RpcFeerateBucket.fromPartial(e)) || [];
    return message;
  }
};

function createBaseRpcFeeEstimateVerboseExperimentalData(): RpcFeeEstimateVerboseExperimentalData {
  return {
    mempoolReadyTransactionsCount: 0,
    mempoolReadyTransactionsTotalMass: 0,
    networkMassPerSecond: 0,
    nextBlockTemplateFeerateMin: 0,
    nextBlockTemplateFeerateMedian: 0,
    nextBlockTemplateFeerateMax: 0
  };
}

export const RpcFeeEstimateVerboseExperimentalData: MessageFns<RpcFeeEstimateVerboseExperimentalData> = {
  encode(message: RpcFeeEstimateVerboseExperimentalData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mempoolReadyTransactionsCount !== 0) {
      writer.uint32(8).uint64(message.mempoolReadyTransactionsCount);
    }
    if (message.mempoolReadyTransactionsTotalMass !== 0) {
      writer.uint32(16).uint64(message.mempoolReadyTransactionsTotalMass);
    }
    if (message.networkMassPerSecond !== 0) {
      writer.uint32(24).uint64(message.networkMassPerSecond);
    }
    if (message.nextBlockTemplateFeerateMin !== 0) {
      writer.uint32(89).double(message.nextBlockTemplateFeerateMin);
    }
    if (message.nextBlockTemplateFeerateMedian !== 0) {
      writer.uint32(97).double(message.nextBlockTemplateFeerateMedian);
    }
    if (message.nextBlockTemplateFeerateMax !== 0) {
      writer.uint32(105).double(message.nextBlockTemplateFeerateMax);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcFeeEstimateVerboseExperimentalData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcFeeEstimateVerboseExperimentalData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mempoolReadyTransactionsCount = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mempoolReadyTransactionsTotalMass = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.networkMassPerSecond = longToNumber(reader.uint64());
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.nextBlockTemplateFeerateMin = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 97) {
            break;
          }

          message.nextBlockTemplateFeerateMedian = reader.double();
          continue;
        }
        case 13: {
          if (tag !== 105) {
            break;
          }

          message.nextBlockTemplateFeerateMax = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RpcFeeEstimateVerboseExperimentalData>): RpcFeeEstimateVerboseExperimentalData {
    return RpcFeeEstimateVerboseExperimentalData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcFeeEstimateVerboseExperimentalData>): RpcFeeEstimateVerboseExperimentalData {
    const message = createBaseRpcFeeEstimateVerboseExperimentalData();
    message.mempoolReadyTransactionsCount = object.mempoolReadyTransactionsCount ?? 0;
    message.mempoolReadyTransactionsTotalMass = object.mempoolReadyTransactionsTotalMass ?? 0;
    message.networkMassPerSecond = object.networkMassPerSecond ?? 0;
    message.nextBlockTemplateFeerateMin = object.nextBlockTemplateFeerateMin ?? 0;
    message.nextBlockTemplateFeerateMedian = object.nextBlockTemplateFeerateMedian ?? 0;
    message.nextBlockTemplateFeerateMax = object.nextBlockTemplateFeerateMax ?? 0;
    return message;
  }
};

function createBaseGetFeeEstimateRequestMessage(): GetFeeEstimateRequestMessage {
  return {};
}

export const GetFeeEstimateRequestMessage: MessageFns<GetFeeEstimateRequestMessage> = {
  encode(_: GetFeeEstimateRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeeEstimateRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeeEstimateRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetFeeEstimateRequestMessage>): GetFeeEstimateRequestMessage {
    return GetFeeEstimateRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetFeeEstimateRequestMessage>): GetFeeEstimateRequestMessage {
    const message = createBaseGetFeeEstimateRequestMessage();
    return message;
  }
};

function createBaseGetFeeEstimateResponseMessage(): GetFeeEstimateResponseMessage {
  return { estimate: undefined, error: undefined };
}

export const GetFeeEstimateResponseMessage: MessageFns<GetFeeEstimateResponseMessage> = {
  encode(message: GetFeeEstimateResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.estimate !== undefined) {
      RpcFeeEstimate.encode(message.estimate, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeeEstimateResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeeEstimateResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.estimate = RpcFeeEstimate.decode(reader, reader.uint32());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetFeeEstimateResponseMessage>): GetFeeEstimateResponseMessage {
    return GetFeeEstimateResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFeeEstimateResponseMessage>): GetFeeEstimateResponseMessage {
    const message = createBaseGetFeeEstimateResponseMessage();
    message.estimate =
      object.estimate !== undefined && object.estimate !== null
        ? RpcFeeEstimate.fromPartial(object.estimate)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetFeeEstimateExperimentalRequestMessage(): GetFeeEstimateExperimentalRequestMessage {
  return { verbose: false };
}

export const GetFeeEstimateExperimentalRequestMessage: MessageFns<GetFeeEstimateExperimentalRequestMessage> = {
  encode(message: GetFeeEstimateExperimentalRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.verbose !== false) {
      writer.uint32(8).bool(message.verbose);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeeEstimateExperimentalRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeeEstimateExperimentalRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.verbose = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetFeeEstimateExperimentalRequestMessage>): GetFeeEstimateExperimentalRequestMessage {
    return GetFeeEstimateExperimentalRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFeeEstimateExperimentalRequestMessage>): GetFeeEstimateExperimentalRequestMessage {
    const message = createBaseGetFeeEstimateExperimentalRequestMessage();
    message.verbose = object.verbose ?? false;
    return message;
  }
};

function createBaseGetFeeEstimateExperimentalResponseMessage(): GetFeeEstimateExperimentalResponseMessage {
  return { estimate: undefined, verbose: undefined, error: undefined };
}

export const GetFeeEstimateExperimentalResponseMessage: MessageFns<GetFeeEstimateExperimentalResponseMessage> = {
  encode(message: GetFeeEstimateExperimentalResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.estimate !== undefined) {
      RpcFeeEstimate.encode(message.estimate, writer.uint32(10).fork()).join();
    }
    if (message.verbose !== undefined) {
      RpcFeeEstimateVerboseExperimentalData.encode(message.verbose, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeeEstimateExperimentalResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeeEstimateExperimentalResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.estimate = RpcFeeEstimate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verbose = RpcFeeEstimateVerboseExperimentalData.decode(reader, reader.uint32());
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetFeeEstimateExperimentalResponseMessage>): GetFeeEstimateExperimentalResponseMessage {
    return GetFeeEstimateExperimentalResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetFeeEstimateExperimentalResponseMessage>
  ): GetFeeEstimateExperimentalResponseMessage {
    const message = createBaseGetFeeEstimateExperimentalResponseMessage();
    message.estimate =
      object.estimate !== undefined && object.estimate !== null
        ? RpcFeeEstimate.fromPartial(object.estimate)
        : undefined;
    message.verbose =
      object.verbose !== undefined && object.verbose !== null
        ? RpcFeeEstimateVerboseExperimentalData.fromPartial(object.verbose)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

function createBaseGetCurrentBlockColorRequestMessage(): GetCurrentBlockColorRequestMessage {
  return { hash: '' };
}

export const GetCurrentBlockColorRequestMessage: MessageFns<GetCurrentBlockColorRequestMessage> = {
  encode(message: GetCurrentBlockColorRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== '') {
      writer.uint32(10).string(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentBlockColorRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentBlockColorRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetCurrentBlockColorRequestMessage>): GetCurrentBlockColorRequestMessage {
    return GetCurrentBlockColorRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrentBlockColorRequestMessage>): GetCurrentBlockColorRequestMessage {
    const message = createBaseGetCurrentBlockColorRequestMessage();
    message.hash = object.hash ?? '';
    return message;
  }
};

function createBaseGetCurrentBlockColorResponseMessage(): GetCurrentBlockColorResponseMessage {
  return { blue: false, error: undefined };
}

export const GetCurrentBlockColorResponseMessage: MessageFns<GetCurrentBlockColorResponseMessage> = {
  encode(message: GetCurrentBlockColorResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blue !== false) {
      writer.uint32(8).bool(message.blue);
    }
    if (message.error !== undefined) {
      RPCError.encode(message.error, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentBlockColorResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentBlockColorResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blue = reader.bool();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.error = RPCError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetCurrentBlockColorResponseMessage>): GetCurrentBlockColorResponseMessage {
    return GetCurrentBlockColorResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrentBlockColorResponseMessage>): GetCurrentBlockColorResponseMessage {
    const message = createBaseGetCurrentBlockColorResponseMessage();
    message.blue = object.blue ?? false;
    message.error =
      object.error !== undefined && object.error !== null ? RPCError.fromPartial(object.error) : undefined;
    return message;
  }
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
